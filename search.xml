<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[CICE 使用手册]]></title>
      <url>http://nearsc.github.io/2017/08/23/cice-intro/</url>
      <content type="html"><![CDATA[<p>在学习模式以及调试模式的过程中，我不太习惯把每个步骤或细节都记录下来，也懒得把一些关于模式的有用信息整理成文档。我自己要查看某些信息的时候，就直接去源代码里看了。话虽如此，整理工作还是很有必要的。这里就先写一份海冰模式 CICE 的使用手册，以供师弟师妹们查阅。</p>
<a id="more"></a>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>正式开始之前，我们需要做好两方面的准备工作，即下载<code>模式代码</code>和<code>模式数据</code>，并将它们上传到服务器。在我们服务器上，我已经把代码和数据放到了相应的目录下：</p>
<ol>
<li>模式代码<blockquote>
<p>/home/public/practice/cice/cice.v5.0</p>
</blockquote>
</li>
<li>模式数据<blockquote>
<p>/home/data/model-forcing/cice</p>
</blockquote>
</li>
</ol>
<p>模式代码目录下有两个文件夹：<code>Original</code> 和 <code>test</code>。其中 <code>Original</code> 下存放的是网上的原始代码，而 <code>test</code> 下存放的是我修改过的能够快速使用的代码。<code>test</code> 中所做的修改是关于环境配置以及模式配置的，可以之后再慢慢去了解。<br>我们需要做的是，在自己的帐号目录下建立一个存放模式试验的文件夹，然后将模式代码拷贝到那个文件夹下。以我的帐号为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 ~]$ cd ~/tmp</span><br><span class="line">[scnie@Leo1 tmp]$ cp -r /home/public/practice/cice/cice.v5.0/test test1</span><br><span class="line">[scnie@Leo1 tmp]$ cd test1</span><br><span class="line">[scnie@Leo1 test1]$ ls</span><br><span class="line">readme.txt  src</span><br></pre></td></tr></table></figure></p>
<p>在我建立的 <code>test1</code> 目录下，有一个 <code>src</code> 文件夹和一个 <code>readme.txt</code> 文件。源代码即存放在 <code>src</code> 里，而 <code>readme.txt</code> 则用来记录该试验（test1）的相关信息。如果你要做另一个试验，并创建了文件夹 <code>test2</code>，那么就可以修改 <code>test2/readme.txt</code> 里的内容，以记录 test2 所作的改动。这样的做法有利于之后快速区分不同试验间的主要差异。<br>模式数据不需要拷贝，因为数据量较大，如果每个人都把它拷贝到自己的帐号目录里，就会占用过多的硬盘空间。实际上我们就把它放在 <code>/home/data/model-forcing/cice</code> 里，然后都读取那个目录下的文件就行了。<br>P. S.：一定要记着把 <code>/home/public/practice/cice/cice.v5.0/test</code> 拷贝成新的文件夹（如test1），不要直接对那个公共目录进行修改。当然，你也没有权限修改它。</p>
<h2 id="模式编译"><a href="#模式编译" class="headerlink" title="模式编译"></a>模式编译</h2><p>因为我们拷贝的是 <code>/home/public/practice/cice/cice.v5.0/test</code> 这个能快速使用的代码，而不是网上的原始代码（<code>Original</code> 文件夹），所以只需要做少量改动，就可以进行模式编译了。首先对 <code>comp_ice</code> 文件进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 test1]$ cd src</span><br><span class="line">[scnie@Leo1 src]$ vi comp_ice</span><br></pre></td></tr></table></figure></p>
<p>修改 <code>comp_ice</code> 开头部分的 <code>SYSTEM_USERDIR</code> 字段，将后面的路径改为自己的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/csh -f</span><br><span class="line"></span><br><span class="line">### Change these to your own site and user directory! </span><br><span class="line">### You will need to create a Makefile Macro in bld/ and a run_ice script </span><br><span class="line">### in input_templates/.</span><br><span class="line">setenv SITE NJU-atm.ibm   # also works for mustang</span><br><span class="line">#setenv SITE LANL.bigsuze</span><br><span class="line"></span><br><span class="line">### SYSTEM_USERDIR is predefined on ORNL machines</span><br><span class="line">setenv SYSTEM_USERDIR /home/scnie/tmp/test1  # ibm</span><br><span class="line">#setenv SYSTEM_USERDIR /Users/akt/Work/MPAS-CICE/Column_Package/cice_package/run_dirs</span><br><span class="line"></span><br><span class="line">### Grid resolution</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>然后运行 <code>comp_ice</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 src]$ ./comp_ice</span><br></pre></td></tr></table></figure></p>
<p>模式就自行开始编译了。如果最终出现这样的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/home/scnie/tmp/test1/rundir</span><br><span class="line">NTASK = 20</span><br><span class="line">global N, block_size</span><br><span class="line">x    320,    32</span><br><span class="line">y    384,    96</span><br><span class="line">max_blocks = 2</span><br><span class="line">1 = TRAGE, iage tracer</span><br><span class="line">1 = TRFY, first-year ice tracer</span><br><span class="line">1 = TRLVL, level-ice tracers</span><br><span class="line">1 = TRPND, melt pond tracers</span><br><span class="line">0 = NTRAERO, number of aerosol tracers</span><br><span class="line">0 = TRBRI, brine height tracer</span><br><span class="line">7 = NBGCLYR, number of bio grid layers</span><br><span class="line">0 = TRBGCS, number of BGC tracers</span><br></pre></td></tr></table></figure></p>
<p>就说明编译成功了。此时，会在上一级目录生成一个 <code>rundir</code> 文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 src]$ cd ..</span><br><span class="line">[scnie@Leo1 test1]$ ls</span><br><span class="line">readme.txt  rundir  src</span><br></pre></td></tr></table></figure></p>
<p>模式的运行将在 <code>rundir</code> 里面进行。</p>
<h2 id="模式运行"><a href="#模式运行" class="headerlink" title="模式运行"></a>模式运行</h2><p>模式编译完之后，进入 <code>rundir</code>，执行 <code>run_ice</code> ，模式就开始运行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 test1]$ cd rundir</span><br><span class="line">[scnie@Leo1 rundir]$ ls</span><br><span class="line">cice  compile  grid  history  ice_in  kmt  restart  run_ice</span><br><span class="line">[scnie@Leo1 rundir]$ ./run_ice</span><br></pre></td></tr></table></figure></p>
<p>模式输出结果将存放在 <code>history</code> 下。当然，要等到模式结果全部输出，估计至少要等十个小时。不过一旦模式开始运行了，你就可以退出登录了，模式不会因为你退出服务器而中断的。<br>如果你发现已经运行的模式试验存在问题，想要终止正在运行的模式，那么可以先用 <code>ps</code> 命令查询你的进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 ~]$ ps -ef|grep scnie</span><br><span class="line">scnie    25877     1  0 18:13 ?        00:00:00 mpirun -n 20 cice</span><br><span class="line">scnie    25878 25877 98 18:13 ?        00:08:16 cice</span><br><span class="line">scnie    25879 25877 99 18:13 ?        00:08:20 cice</span><br><span class="line">scnie    25880 25877 99 18:13 ?        00:08:20 cice</span><br><span class="line">scnie    25881 25877 99 18:13 ?        00:08:20 cice</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>注意这里的 <code>scnie</code> 要改成你自己的用户名。从显示的进程中找到 <code>mpirun -n 20 cice</code>，然后读取它的进程号（第二列），这里进程号是 <code>25877</code>。再用 <code>kill</code> 命令杀掉它就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 ~]$ kill 25877</span><br></pre></td></tr></table></figure></p>
<p>这样模式就退出运行了。之后你会发现，<code>history</code> 下不会再有新的文件生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 rundir]$ ls history</span><br><span class="line">iceh.1979-01.nc  iceh_ic.1979-01-01-00000.nc</span><br></pre></td></tr></table></figure></p>
<p>日志文件里面也有程序终止的相关信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 rundir]$ tail -n 1 170823-181336.out </span><br><span class="line">20 total processes killed (some possibly by mpirun during cleanup)</span><br></pre></td></tr></table></figure></p>
<p>以及再次使用 <code>ps</code> 命令时，<code>cice</code> 的进程全部消失：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[scnie@Leo1 rundir]$ ps -ef|grep scnie</span><br><span class="line">root     25976  5300  0 18:21 ?        00:00:00 sshd: scnie [priv]</span><br><span class="line">scnie    25978 25976  0 18:21 ?        00:00:00 sshd: scnie@pts/2</span><br><span class="line">scnie    25979 25978  0 18:21 pts/2    00:00:00 -bash</span><br><span class="line">scnie    26046 25979  0 18:31 pts/2    00:00:00 ps -ef</span><br><span class="line">scnie    26047 25979  0 18:31 pts/2    00:00:00 grep --color=auto scnie</span><br></pre></td></tr></table></figure></p>
<p>通过上面的这些操作，你就可以最低限度地正常使用 CICE 了。至于如何进一步控制 CICE 的模拟（如修改模拟时段等），我会在后面的内容里提供相关信息以及具体操作方法。<br>对了，有一点需要注意一下，由于我们服务器较小，最好不要同时运行多个模式试验。所以运行模式前相互打好招呼，一次只由一人运行一个模式试验，不然服务器会变得特别慢~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 入门教程——服务器使用]]></title>
      <url>http://nearsc.github.io/2017/08/22/06climate-linux-intro-7/</url>
      <content type="html"><![CDATA[<p>气象家园投稿第七篇：服务器使用</p>
<a id="more"></a>
<p>“Linux 入门教程”系列终于要进入尾声啦！在这最后一期里，我想讲讲有关服务器使用的一些问题。那么为什么要使用服务器呢，自己电脑不够用吗？是的！在科研刚开始的阶段，我也只是用个人电脑下下数据画画图，可是到后面接触了模式以后，计算量太大，数据也很多，就不得不依赖服务器了。服务器其实可以理解成比较厉害的计算机，其运算速度快，存储空间大，因此数值模式一般都会在服务器上运行。但正因为服务器比较好用，大家都抢着用它，所以“多个用户如何充分利用好服务器的计算资源”就变得非常重要。这意味着，同样是使用 Linux 系统，在服务器上就需要考虑一些新的问题。</p>
<h1 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h1><p>相比于个人电脑，服务器通常是多用户的，而且是多个用户同时使用的。在服务器管理员的管理下，每个用户在自己的目录下做着自己的事情，不会相互打扰。假如我现在向某个服务器的管理员申请到了一个帐户，可我要去哪里打开服务器并登录自己的帐号呢？实际上服务器一直都处于开机状态，并被集中放置在机房里，由专人进行管理，用户们只需要登录并使用它即可。当然大家并不会跑到机房里进行登录，而是采取远程登录的方式，只要连上局域网，就能在实验室或者宿舍使用服务器了。<br>不管自己的电脑是 Windows 系统还是 Linux 系统，我们一般都会采用 ssh 协议进行远程登录。在 Linux 下，输入 <code>ssh</code> 命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ ssh $user@$ip</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>$user</code> 是你在服务器上的用户名，<code>$ip</code> 则是服务器的 IP 地址，输入命令后系统会提示你继续输入密码。如果是第一次连接，还会有个小提示，输 yes 就行啦。不过还有关于图形系统（X Window System）的问题，即按照上述命令登录以后，是无法进行画图显示的。比如我用 ncl 打开一个 x11，会显示 <code>--X driver error: DISPLAY environment variable not set</code>；再试试运行 MATLAB，发现它并没有启动图形窗口，而是直接进入了命令行模式。如果想要正常使用图形系统，只需在登录时加上一个选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ ssh -X $user@$ip</span><br></pre></td></tr></table></figure></p>
<p>如果想在 Windows 系统下登录服务器，则需要下载一个远程登录软件。这里我推荐一下 Xmanager，感觉它使用起来相对比较友好。Xmanager 包含多个应用程序，其中 Xshell 就是用来进行远程登录的，选择协议为 ssh 之后填上用户名、密码和 IP 就 OK 了。若要使用图形系统，记得运行一下 Xmanager - Passive。</p>
<h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><p>远程登录没有问题了，可如何在个人电脑和服务器间进行文件传输呢？通常也是采用的 ssh 协议。如果使用 Linux 系统，则会用到 <code>scp</code> 命令，其用法类似于 <code>cp</code> 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ scp $user@$ip:$file $des</span><br><span class="line">[N@Dell ~]$ scp $file $user@$ip:$des</span><br></pre></td></tr></table></figure></p>
<p>同样需要指定用户名、服务器 IP，同时要指明源文件 <code>$file</code> 及目标地址 <code>$des</code>。这里第一行是从服务器下载至本地，第二行是从本地上传至服务器，实际上就是在 <code>cp</code> 的用法基础上加入了 <code>$user@$ip</code>。如果要传输文件夹，当然也是加上 <code>-r</code> 选项啦（类似于 <code>cp</code> ）！<br>对了，顺带提一下 <code>rsync</code> 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ rsync -P --rsh=ssh $user@$ip:$file $dir</span><br><span class="line">[N@Dell ~]$ rsync -P --rsh=ssh $file $user@$ip:$dir</span><br></pre></td></tr></table></figure></p>
<p>这是一个远程同步工具，功能比较强大。我们可以用它来代替 <code>scp</code> 进行文件传输，因为它能实现断点续传。这里不多做介绍了，大家可以自行百度。<br>对于 Windows 系统，假如你使用的是 Xmanager，只需要点击 Xshell 工具栏的“新建文件传输”按钮，就会出现文件传输的窗口了。咦，这个文件传输窗口叫 Xftp，难道是采用的 ftp 协议吗？可是我们服务器都没开 ftp 协议，不可能是 ftp 传输的，所以我猜测其实相当于用了 <code>scp</code> 命令。不过我也没有仔细去研究它 (;-_-)</p>
<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>尽管服务器性能优良，但用户一多就得考虑合理分配的问题。而作为用户，我们要时刻注意自己的使用情况，如 CPU 和内存的占用率、磁盘配额、文件系统限制等等。由于用户管理是一个比较大的问题，我现有的经验也比较零散，所以决定从几个重要命令入手，给大家说说我关注的问题吧。<br><code>free</code>、<code>top</code><br><code>free</code> 可以查看内存使用情况，而 <code>top</code> 可以查看进程的 CPU 占用率、内存占用率、优先级等。这类似于在 Windows 下查看任务管理器，来了解机器运行状况。如果服务器负载过高，可以跟管理员反馈反馈。<br><code>df</code>、<code>du</code><br>了解服务器的总存储空间大小是很重要的，所以需要用到 <code>df</code> 命令。知道了总空间大小，当然也得知道自己目录占了多少空间，一般输入 <code>du -sh dir</code> 就可以查看 <code>dir</code> 的大小了。<br><code>ps</code><br><code>ps</code> 可以查看进程的运行情况。直接输 <code>ps</code> 可以查看当前会话的进程，若要查看自己所有的进程（包括其他会话的进程以及后台进程），则可以输入 <code>ps -fu $user</code>，<code>$user</code> 即用户名。若输入 <code>ps -fe</code>，则会显示所有用户的所有进程。<br><code>quota</code><br>因为服务器是供多用户使用的，所以对每个用户限定其可用磁盘空间也是理所当然的。大家使用服务器时是否遇到过无法写入磁盘的问题呢？有可能就是磁盘额度不够造成的。如果额度不够了，就只能删掉那些没用的文件，释放空间之后才能写入。这时候就得用 <code>quota</code> 看看总额度是多少，以及需要腾出多少空间。<br><code>ulimit</code><br>除了磁盘空间，用户的可打开文件数、可使用内存总量、可使用进程数等等也会被限制，相关信息的查看与设置需要用到 <code>ulimit</code> 命令。如 <code>ulimit -n</code> 设置可打开文件数，<code>ulimit -u</code> 设置可使用进程数。还有在运行模式时，如果出现 <code>segmentation fault</code>，有可能是 <code>ulimit</code> 设置问题，可以尝试输入 <code>ulimit -s unlimited</code> 来解决。需要注意的是，用户并不能随心所欲地使用 <code>ulimit</code> 来进行调整哦~</p>
<h1 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h1><p>有时候我们的程序要运行很久，如果需要等它运行完才能进行其他操作，难免会有不便之处。解决的办法就是把程序挂到后台运行，这样就能继续输入其他命令，甚至退出登录也不会影响程序的运行。<br>比如我在服务器上运行 <code>matlab</code> 之后，会话窗口就不能输入其他命令了。这时按下 <code>Ctrl+z</code>，<code>matlab</code> 会被临时挂起，输入 <code>jobs</code> 就能查看到 <code>matlab</code> 的运行情况。根据 <code>jobs</code> 的显示，我们再使用 <code>bg</code> 命令，即可把 <code>matlab</code> 移至后台。具体过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ matlab</span><br><span class="line">[Ctrl+z]</span><br><span class="line">[1]+  Stopped                 matlab</span><br><span class="line">[N@Dell ~]$ bg 1</span><br><span class="line">[1]+ matlab &amp;</span><br><span class="line">[N@Dell ~]$</span><br></pre></td></tr></table></figure></p>
<p>当然，我们也可以通过 <code>fg 1</code> 命令，来将 <code>matlab</code> 重新移至前台，此时又回到了无法继续输入命令的状态。<br>让我们考虑另一种情况：我用 ncl 对大量数据进行插值，并将插值后的数据保存成文件，但我算了一下时间，完成所有插值需要一天，那我岂不是要一整天都开着电脑并保持登录状态？万一网络出错，连接超时了，程序不就断啦！没错，这样就需要后台运行了，不过为了保证退出登录后程序仍会运行，需要用到 <code>nohup</code> 命令。由于上述 <code>matlab</code> 例子的操作比较繁琐，我们采用一种更为简便的方式来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ nohup ncl interp.ncl &gt; interp.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p>
<p>平常情况下，我们会输入 <code>ncl interp.ncl</code> 来运行脚本。而这里，首先我通过 <code>&gt; interp.log 2&gt;&amp;1</code> 将标准输出和标准错误输出重定向到 <code>interp.log</code> 文件里。然后在命令末端加上 <code>&amp;</code> 符号，可将程序移至后台运行。最后在命令首端加上 <code>nohup</code>，以保证退出登录后程序不会中断。之后就可以退出登录，关闭电脑，等一天过后再来查看了。<br>关于程序的后台运行，我只推荐在小型服务器上进行，如自己老板的服务器。对于大型服务器，如全院或全校共同使用的机群，就不要自行将程序移至后台了。对于机群来说（机群包含多台计算机，每台计算机为一个节点），通常会分成登录节点和计算节点，各种程序都应该被放到计算节点上运行。按照刚才的方式，我们会直接在登录节点上将程序转至后台，而无法将它们放到计算节点上去。另一方面，即使是登录到计算节点后再进行后台运行，如果多个用户在同一节点上长时间运行程序，该节点就会变得拥挤，而其他节点却很空闲，这样就不利于服务器的合理利用了。因此服务器通常不会允许用户长时间地自行运行程序（不管是前台运行还是后台运行），而是让用户经由作业系统来运行大型程序。</p>
<h1 id="作业系统"><a href="#作业系统" class="headerlink" title="作业系统"></a>作业系统</h1><p>对于机群而言，用户一般在登录节点上登录，但不在登录节点上运行程序，而是经由系统将程序放到计算节点上。其中完成分配工作的就是作业系统了。当新任务提交时，作业系统会对目前机群使用情况进行分析，并根据该任务所需资源，来决定最终使用哪几个计算节点。作业系统实际上就是个管理软件，而这管理软件在不同服务器上可能是不同的。我之前在好几个服务器上接触了不同的作业系统（如 SLURM、Platform LSF 和 LoadLeveler），发现不同的作业系统有着相同的用法，学起来也是一通百通。这里我就以 Platform LSF 为例来讲讲基本用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ bhosts</span><br><span class="line">[N@Dell ~]$ bsub -a openmpi -n 40 -e test.err -o test.out mpirun.lsf ./test</span><br><span class="line">[N@Dell ~]$ bjobs</span><br><span class="line">[N@Dell ~]$ bkill jobid</span><br></pre></td></tr></table></figure></p>
<p>首先 <code>bhosts</code> 可以查看各节点的占用情况，然后用 <code>bsub</code> 来提交作业，之后用 <code>bjobs</code> 查看当前作业运行情况，而如果想终止作业的话可以使用 <code>bkill</code>。其中 <code>bsub</code> 后的 <code>-a openmpi</code> 指定了采用的并行方式为 <code>openmpi</code>，<code>-n 40</code> 指定程序将使用40个核，<code>-e test.err -o test.out</code> 指定标准输出和错误输出的日志文件，<code>mpirun.lsf ./test</code> 则为所运行的程序。<code>bkill</code> 之后接作业编号，该编号由 <code>bjobs</code> 查询得到。<br>简单来看，使用作业系统基本就是这四条命令了，是不是很简单呢？当然你可以自己去查看其他命令，也可以去了解其他作业系统，这里我就不再赘述了。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>终于到了完结撒花的时候啦！虽说一开始我就已经想好所有7期的主题了，但在确定每期的具体内容时总是思前想后，困扰不已，也曾因为太忙而拖了好久没写。这个系列算是我第一次尝试在微信公众号上发表连载文章，只能说深切体会到了写文章的不易。当然了，我感觉自己得到了不少锻炼，也希望大家看了我的文章以后能有一些帮助。如果大家觉得我写得不好，欢迎指正，任何合理意见与建议我都会好好听取的，下次再有机会的话我会努力做更好~ ◕‿◕</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 入门教程——模式使用]]></title>
      <url>http://nearsc.github.io/2017/08/21/06climate-linux-intro-6/</url>
      <content type="html"><![CDATA[<p>气象家园投稿第六篇：模式使用</p>
<a id="more"></a>
<p>前面我们已经讲过了如何在 Linux 下编写程序以及安装软件，在此基础上，我想大家都已对 Linux 系统有了更深的了解，那就让我们开始介绍如何在 Linux 下使用模式吧！等等，你觉得自己用不到模式，而且觉得模式很难，所以不想看本期内容？咳咳，首先，我觉得作为一名大气的研究生，模式使用应该算是基本技能，大家都会只有自己不会还是很难过的～其次，使用模式并不困难，只需要了解一些主要概念，再敲敲键盘，就行了。要说模式的真正困难之处，应该是模式的发展吧，那就需要对模式的每一部分都比较熟知了。本期内容从区域气候模式 RegCM 入手，但不会以它为中心，而是重点介绍模式使用的一般性规律。这样的话即使换成其他模式，大家也能稍作变通，自行解决了。</p>
<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>记得还未接触模式之前，我在课堂上听老师介绍了各种各样的模式，心想要是想多学几个的话不得花好多时间？后来我才意识到，确实不可能把各种模式里面的各个物理过程都弄清楚，但起码学会使用不同的模式并不太难，因为各个模式的用法其实是大同小异的。那么模式使用的基本思路是什么呢？根据之前积累的经验，我觉得不管是使用什么模式，大致都可以分为五个步骤：环境配置、编译模式、模式配置、运行模式、分析结果。具体而言：</p>
<ol>
<li>环境配置：需要设置所用的编译器、编译选项及依赖的库。</li>
<li>编译模式：通过编译生成可执行文件，大多数模式使用 Makefile 进行编译。</li>
<li>模式配置：为模式运行准备必要的数据，并对模式配置文件进行修改。</li>
<li>运行模式：运行编译所得的程序，通常模式会以并行的方式来运行。</li>
<li>结果分析：模式运行结束后，对模式输出数据进行分析。</li>
</ol>
<p>有了基本思路，我们就可以随便找一个模式试一试了。话虽如此，刚开始使用模式的时候还是会遇到许多小问题，但随着接触越来越多，对新模式的掌握也会越来越快。RegCM 对于我来说也是一个全新的模式，那么接下来就看看我是否能够顺利使用它吧～<br>正式开始之前，我们先去官网下载 RegCM 的源码。这里我选择的是下载次数最多的 RegCM-4.5.0 版本，顺便还下了份用户手册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell regcm]$ ls</span><br><span class="line">doc  RegCM-4.5.0</span><br><span class="line">[N@Dell regcm]$ cd RegCM-4.5.0/</span><br><span class="line">[N@Dell RegCM-4.5.0]$ curl -O http://gforge.ictp.it/gf/download/frsrelease/252/1580/RegCM-4.5.0.tar.gz</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 10.6M  100 10.6M    0     0  32919      0  0:05:39  0:05:39 --:--:--  340k</span><br><span class="line">[N@Dell RegCM-4.5.0]$ cd ../doc/</span><br><span class="line">[N@Dell doc]$ curl -O http://gforge.ictp.it/gf/download/docmanfileversion/97/1690/UserGuide.pdf</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  407k  100  407k    0     0   113k      0  0:00:03  0:00:03 --:--:--  113k</span><br><span class="line">[N@Dell doc]$ cd ../RegCM-4.5.0/</span><br><span class="line">[N@Dell RegCM-4.5.0]$ tar -zxvf RegCM-4.5.0.tar.gz &gt; /dev/null </span><br><span class="line">[N@Dell RegCM-4.5.0]$ mv RegCM-4.5.0 Original</span><br><span class="line">[N@Dell RegCM-4.5.0]$ cp -r Original test1</span><br></pre></td></tr></table></figure></p>
<p>P.S.：由于个人习惯，我把解压得到的文件夹改名成 <code>Original</code>，然后复制成 <code>test1</code>，而之后的模式使用过程将在 <code>test1</code> 里进行。</p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>一个模式相当于是一个软件，而现在我们就是在源码安装一个软件而已，所以根据上期介绍的内容，我们得先解决编译环境的问题，即对编译器、编译选项、依赖库等进行设置。那么具体要进行哪些操作呢？这个一般都可以在模式的用户手册或者 <code>INSTALL</code> 文件里查看。比如在我刚下载的用户手册中，3.1节介绍了 RegCM 所需要的依赖软件，3.2节则说明了如何进行设置。根据提示，环境配置过程大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell RegCM-4.5.0]$ ls</span><br><span class="line">Original  RegCM-4.5.0.tar.gz  test1</span><br><span class="line">[N@Dell RegCM-4.5.0]$ cd test1/</span><br><span class="line">[N@Dell test1]$ ./configure CC=icc FC=ifort &gt; config.output 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>在 RegCM 里，环境配置是通过 <code>configure</code> 来实现的，可以看到我这里指定了将会使用 intel compiler 对 RegCM 进行编译。等一下，怎么这么简单？这里怎么就指定了一下编译器，不是说要设置依赖软件所在路径的吗？实际上我们需要设置 intel compiler，netcdf，openmpi，hdf5 等软件的路径，不过我都已经安装过，并在 <code>.bashrc</code> 文件里设置好了：<br><img src="/2017/08/21/06climate-linux-intro-6/pic_1.png" alt="pic_1.png" title=""><br>如果你仔细查看刚才操作所生成的 <code>config.output</code> 和 <code>config.log</code> 文件里的内容，就会发现 RegCM 确实找到了那些它所需要的库。最重要的是，<code>config.log</code> 文件的最后显示的是 <code>exit 0</code>，Makefile 文件也已经生成，这意味着我们的环境配置成功了！<br>需要说明一下的是，不是所有模式都会通过 <code>configure</code> 来实现环境配置，比如有的模式会让我们直接去修改某个文件。对于更为复杂的模式（如气候系统模式），则需要修改多个文件、执行多个脚本。总之，在熟悉各种模式的套路之前，就多看看它们的用户手册吧～</p>
<h1 id="编译模式"><a href="#编译模式" class="headerlink" title="编译模式"></a>编译模式</h1><p>环境配置完成之后，就可以进行编译了，这里我们通过 <code>make</code>（它会自动读取 Makefile 文件）来编译 RegCM：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell test1]$ make</span><br><span class="line">CDPATH=&quot;$&#123;ZSH_VERSION+.&#125;:&quot; &amp;&amp; cd . &amp;&amp; /bin/sh /home/N/Model/regcm/RegCM-4.5.0/test1/missing aclocal-1.14 </span><br><span class="line">/home/N/Model/regcm/RegCM-4.5.0/test1/missing: line 81: aclocal-1.14: command not found</span><br><span class="line">WARNING: &apos;aclocal-1.14&apos; is missing on your system.</span><br><span class="line">         You should only need it if you modified &apos;acinclude.m4&apos; or</span><br><span class="line">         &apos;configure.ac&apos; or m4 files included by &apos;configure.ac&apos;.</span><br><span class="line">         The &apos;aclocal&apos; program is part of the GNU Automake package:</span><br><span class="line">         &lt;http://www.gnu.org/software/automake&gt;</span><br><span class="line">         It also requires GNU Autoconf, GNU m4 and Perl in order to run:</span><br><span class="line">         &lt;http://www.gnu.org/software/autoconf&gt;</span><br><span class="line">         &lt;http://www.gnu.org/software/m4/&gt;</span><br><span class="line">         &lt;http://www.perl.org/&gt;</span><br><span class="line">make: *** [aclocal.m4] Error 127</span><br></pre></td></tr></table></figure></p>
<p>完了，出错了，怎么跟手册上说的不一样啊！正如前面所说，虽然知道了模式使用的五大步骤，也有用户手册供我们参考，可真正操作的时候还是会遇到一些小问题。这个时候，就需要百度、Google 了。若是搜索不到相关信息，可能还得去各种论坛提问，等待别人回答。当然在积累了一定经验之后，可以尝试自己分析、解决问题。这样的话，即使百度、Google 帮不上忙，也不必去论坛求助别人啦（毕竟大神们不一定有空～）。好了，回到我们的 RegCM，看看如何解决吧！<br>根据错误提示信息，大概意思是找不到 <code>aclocal-1.14</code>，而这个东东貌似是 Automake 里面的一个小程序。然后我查看了 RegCM 目录下的 <code>aclocal.m4</code> 文件，似乎 RegCM-4.5.0 使用的 Automake 版本是 1.14.1，而本机版本为 1.13.4。既然如此，我们先更新 Automake（具体过程不再赘述），之后重新 <code>configure</code> 一下就可以 <code>make</code> 啦！这里我直接把 <code>make</code> 的输出信息存到 <code>make.output</code> 文件里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell test1]$ make all install &gt; make.output 2&gt;&amp;1</span><br><span class="line">[N@Dell test1]$ ls bin/</span><br><span class="line">average     GrADSNcPlot     interp_bionox     regcmMPI  sigma2z</span><br><span class="line">chem_icbc   GrADSNcPrepare  interp_emissions  regrid    sst</span><br><span class="line">emcre_grid  icbc            interp_pollen     sigma2p   terrain</span><br></pre></td></tr></table></figure></p>
<p><code>make</code> 结束之后，会发现 <code>bin</code> 文件夹（之前为空文件夹）下出现了多个可执行文件，<code>make.output</code> 文件里也没有错误信息，这说明编译已经成功了。虽说我这里是把 Automake 更新了才顺利编译的，但实际上还有其他解决方式。比如我们也可以通过修改一些文件而使 RegCM-4.5.0 直接采用 1.13.4 版本的 Automake，不过这对于经验不够的同学来说可能相对困难一些～<br>其实我这次编译 RegCM 还是挺顺利的，才遇到一个问题。想想以前编译某些模式的时候，都记不清报过多少次错，整了好久才成功。也许你在编译某个模式的时候也遇到了一堆问题，但千万别放弃，最后肯定能成功的！</p>
<h1 id="模式配置"><a href="#模式配置" class="headerlink" title="模式配置"></a>模式配置</h1><p>既然模式编译好了，那可以开始运行了吧？别急，我们还得准备好模式所需的数据，并对配置文件进行修改。<br>首先是数据的准备。如果我要用 RegCM 来做一系列科学问题，会需要准备大量的数据，包括强迫场和初值场等。不过这里我只是演示如何使用 RegCM，运行一个小个例就行了，所以用到的数据不多。官网上提供了一些<a href="http://clima-dods.ictp.it/regcm4" target="_blank" rel="external">数据</a>，我从中选取了一部分进行下载，并存放在 <code>data</code> 文件夹下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell test1]$ cd /home/N/Model/regcm/data/</span><br><span class="line">[N@Dell data]$ ls</span><br><span class="line">CLM  CLM45  EIN15  SST  SURFACE</span><br></pre></td></tr></table></figure></p>
<p>接下来我们准备一个 <code>run</code> 文件夹，用来运行一个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell data]$ cd /home/N/Model/regcm/RegCM-4.5.0/test1/</span><br><span class="line">[N@Dell test1]$ mkdir run</span><br><span class="line">[N@Dell test1]$ cd run</span><br><span class="line">[N@Dell run]$ mkdir input output</span><br><span class="line">[N@Dell run]$ ln -sf ../bin .</span><br><span class="line">[N@Dell run]$ cp ../Testing/test_001.in .</span><br></pre></td></tr></table></figure></p>
<p>新建的 <code>input</code> 和 <code>output</code> 文件夹分别存放输入数据和输出数据，存放可执行文件的 <code>bin</code> 文件夹也被链到 <code>run</code> 文件夹下。这里我们还复制了一个 <code>test_001.in</code> 文件，它就是需要修改的模式配置文件了，里面的信息包括时间设置、网格设置、输出格式、数据路径、各方案参数等等。可能有人会叫它 <code>namelist</code> 文件，因为它是按照 Fortran 里的 namelist 格式写的。当然其他模式可能采用不同的格式，比如有的模式采用 xml 格式，还有的则采用自定格式。对于这个个例，我们只需修改数据路径及模式时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell run]$ sed -i &quot;s/dirter.*$/dirter = &apos;input\/&apos;,/g&quot; test_001.in</span><br><span class="line">[N@Dell run]$ sed -i &quot;s/inpter.*$/inpter = &apos;\/home\/N\/Model\/regcm\/data\/&apos;,/g&quot; test_001.in</span><br><span class="line">[N@Dell run]$ sed -i &quot;s/dirglob.*$/dirglob = &apos;input\/&apos;,/g&quot; test_001.in</span><br><span class="line">[N@Dell run]$ sed -i &quot;s/inpglob.*$/inpglob = &apos;\/home\/N\/Model\/regcm\/data\/&apos;,/g&quot; test_001.in</span><br><span class="line">[N@Dell run]$ sed -i &quot;s/dirout.*$/dirout = &apos;output\/&apos;,/g&quot; test_001.in</span><br><span class="line">[N@Dell run]$ sed -i &quot;s/gdate1.*$/gdate1 = 2000060100,/g&quot; test_001.in</span><br><span class="line">[N@Dell run]$ sed -i &quot;s/gdate2.*$/gdate2 = 2000070100,/g&quot; test_001.in</span><br><span class="line">[N@Dell run]$ sed -i &quot;s/mdate0.*$/mdate0 = 2000060100,/g&quot; test_001.in</span><br><span class="line">[N@Dell run]$ sed -i &quot;s/mdate1.*$/mdate1 = 2000060100,/g&quot; test_001.in</span><br><span class="line">[N@Dell run]$ sed -i &quot;s/mdate2.*$/mdate2 = 2000070100,/g&quot; test_001.in</span><br></pre></td></tr></table></figure></p>
<p>可能有人不清楚 <code>sed</code> 是啥，实际上它是用来修改文件的（可以把它理解成命令行式的 <code>vi</code>）。其实我可以直接用 <code>vi</code> 进行修改，不过为了方便展示我还是选择了 <code>sed</code> 命令。总之，我根据实际情况修改了 <code>dirter</code>、<code>inpter</code>、<code>dirglob</code>、<code>inpglob</code>、<code>dirout</code>、<code>gdate1</code>、<code>gdate2</code>、<code>mdate0</code>、<code>mdate1</code>、<code>mdate2</code> 这几个字段。大致就是指出数据的存放路径，以及设置模拟时段为2000年6月1日至30日。噢，顺便提一下，模拟区域的中心经纬度为 45.39°N、13.48°E，在意大利附近。</p>
<h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><p>对于 RegCM，在正式运行前，还得对初值场、强迫场等数据进行预处理，将该次模拟个例所需的数据提取出来，并完成相关的插值工作。在 <code>bin</code> 文件夹下可以找到 <code>terrain</code>、<code>sst</code>、<code>icbc</code> 这三个可执行程序，<code>terrain</code> 处理地形与土地利用数据，<code>sst</code> 处理海温数据，最后用 <code>icbc</code> 对初值场、强迫场数据进行整合。处理过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell run]$ ./bin/terrain test_001.in &amp;&gt;terrain.log</span><br><span class="line">[N@Dell run]$ ./bin/sst test_001.in &amp;&gt;sst.log</span><br><span class="line">[N@Dell run]$ ./bin/icbc test_001.in &amp;&gt;icbc.log</span><br><span class="line">[N@Dell run]$ ls input/</span><br><span class="line">test_001_DOMAIN000.nc        test_001_ICBC.2000070100.nc  test_001_SST.nc</span><br><span class="line">test_001_ICBC.2000060100.nc  test_001_LANDUSE</span><br></pre></td></tr></table></figure></p>
<p>三个程序均会读取 <code>test_001.in</code> 文件里的信息，并将运行记录保存在各自的 <code>log</code> 文件里。运行结束后可以在 <code>input</code> 文件夹下查看到生成的数据文件，同时三个 <code>log</code> 文件的结尾处均有 <code>Successfully ...</code> 的字样，即数据预处理已完成。嗯，那就开始运行主体程序吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell run]$ mpirun -np 8 ./bin/regcmMPI test_001.in &amp;&gt; regcmMPI.log</span><br><span class="line">[N@Dell run]$ ls output/</span><br><span class="line">test_001_ATM.2000060100.nc  test_001_SRF.2000060100.nc</span><br><span class="line">test_001_RAD.2000060100.nc  test_001_STS.2000060100.nc</span><br><span class="line">test_001_SAV.2000070100.nc</span><br></pre></td></tr></table></figure></p>
<p>运行过程很简单，只需一条命令，不过需要说明下这里是采用并行方式来运行的。所谓并行运行，其实就是提高了模式的运算效率。想想我们现在的个人计算机都是多核的了，而平时运行普通程序的时候实际只用了一个核，其他核要么干自己的事要么就闲着了。所以并行其实就是把模式分成若干份，然后每个核分一份，大家都来参与模式的运算，这样不就快了么？虽说我指定使用八个核来运行 RegCM，但由于我的计算机只是伪八核，以及并行技术的一些问题，实际是达不到八倍速的。RegCM 的输出文件存放在 <code>output</code> 文件夹下，标准输出及错误输出被我存到了 <code>regcmMPI.log</code>。至此，模式运行就完成了，可以稍微看看 <code>regcmMPI.log</code> 里记录的有关模式运行的信息。然后就简单分析下模拟结果吧！</p>
<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>想必这一步就不用我过多描述了，该怎样分析大家会有自己的想法，我就直接按我的想法给大家看看部分模拟结果吧！这里我对2000年6月的模拟结果取月平均值，并画出各个变量的空间分布：<br><img src="/2017/08/21/06climate-linux-intro-6/pic_2.png" alt="pic_2.png" title=""><br><img src="/2017/08/21/06climate-linux-intro-6/pic_3.png" alt="pic_3.png" title=""><br>大致就这样展示一下吧，大家也不要纠结其空间分布是否合理，我也没有用观测数据来验证。毕竟只是运行了一个 test，没有对模式进行调试，就算模拟得不准也是正常的～</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好了，本期内容主要为大家演示了一下我第一次使用 RegCM 的经历，也分享了我对模式使用的基本思路。总体来说还是挺顺利的，都没有遇到那些莫名其妙的问题，不然篇幅可能要更长了&gt;﹏&lt;。当然，如果大家在使用自己的模式时，遇到各种奇葩的问题，欢迎找我讨论（如果我有时间的话 ◠‿◠）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 入门教程——如何安装软件？]]></title>
      <url>http://nearsc.github.io/2017/08/21/06climate-linux-intro-5/</url>
      <content type="html"><![CDATA[<p>气象家园投稿第五篇：如何安装软件？</p>
<a id="more"></a>
<p>上一期曾说过，如果你要在 Linux 下写 Fortran 程序，可能要自行安装 Fortran 编译器；要想读写 nc 文件时，也需要安装 netcdf 库。毫无疑问，新装好的系统当然要根据自己的需求安装一些特定功能的软件啦！不过要在 Linux 下安装软件可不像 Windows 下那样轻松。唔，要是在 Windows 下的话，安装软件只需要“选路径”，“勾选项”和“下一步”就差不多了，图形界面的操作一目了然。可是到了 Linux 下，不光是图形操作变成了字符输入，还得考虑一些环境设置及软件依赖性的问题，确实不太容易啊。哈哈，别急，让我们一起来了解下相关的知识，然后你就会觉得，其实一点也不难嘛！</p>
<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><p>软件的安装方式大概可以分成两种，一种是源码安装，即人家把源代码提供给我们，然后我们在自己机器上编译得到可执行文件；另一种则是软件被预先编译好，我们直接下载可执行文件就能用了。Linux 下的绝大部分软件，都是可以源码安装的，换句话说我们可以获取源代码。许多软件网站上会同时提供两种安装方式，即所谓的 source code 和 binaries。但 Windows 下的软件，开源的软件很少见吧？所以在 Windwos 下安装软件，只是将已编译好的程序复制到你电脑上，再设置设置注册表什么的。<br>使用 binaries 安装是最为简单的，前面已经说过了，下载下来就能用，你唯一要做的事情就是解压一下。虽然简单，但存在不小的局限性，即 binaries 必须是在特定的系统上才行使用。你去随便找个软件的 binaries，就会看到它让你根据你的系统选择版本，以NCL为例：<br><img src="/2017/08/21/06climate-linux-intro-5/pic_1.png" alt="pic_1.png" title=""><br>那万一它不提供我这个系统的呢？比如上面也没有 Fedora 的啊！这个时候可以考虑下个 RHEL 的试试，因为 Fedora 和 RHEL 相对比较接近。可要是不行呢？总不能重新换个系统吧。更别说有的软件还不提供 binaries 呢！<br>没办法，只能源码安装咯。那么上一期所介绍的内容就有些用了，因为采用源码安装软件的方式，实际上就是编译一个程序嘛，只不过比我们自己写的程序大一些而已。这里我想找一个软件来演示下安装过程，最后决定还是以 NCL 为例，但 NCL 的源码安装实在是，太！麻！烦！了！就连官网都这样说：</p>
<blockquote>
<p>“We highly recommend that you use a precompiled NCL binary rather than attempting a build from source code. If you tried a precompiled binary and ran into problems, you can post your problem to the ncl-install email list. If you decide to go forth with building from source code, good luck!”</p>
</blockquote>
<p>好吧……不过我就是喜欢挑战！咳咳，其实也是觉得大多人都没源码装过 NCL，我来介绍介绍也是不错的吧？<br>嗯，我说源码安装就是编译程序，那你会想起这样的命令 <code>compiler -o xxx xxx -Ixxx -Lxxx</code>。不过软件源文件较多，所以是用 Makefile 进行编译。那是用什么编译器，以及所需的头文件和库文件是什么呢？我们得根据软件和系统的实际情况来设置。要是我缺少某个库呢？那就得先把那个库装好，即所谓的依赖性问题：安装该软件时需要依赖其它软件。装好以后还得在 <code>.bashrc</code> 文件里面加上软件路径，有时候还有其他的配置，以便使用。总结一下，源码安装的主要步骤即设置编译环境、编译软件、配置软件。不过不同软件有不同之处，具体某个软件的安装步骤详见其官网及 <code>README</code> 或 <code>INSTALL</code> 文件。好了，下面我给大家演示下源码安装 NCL（<a href="http://www.ncl.ucar.edu/Download/build_from_src.shtml#BuildNCLFromSource" target="_blank" rel="external">参考官网的介绍</a>）。<br>第一步得先解决依赖性问题，即安装 NCL 前，需要先安装其他的软件，这里贴一下官网的列表：<br><img src="/2017/08/21/06climate-linux-intro-5/pic_2.png" alt="pic_2.png" title=""><br>什么？本来我只是要装一个 NCL，现在要装这么多其他的软件？什么什么？怎么我装列表中的某个软件时，它又说我得再装另外几个软件？哦，天哪，到底一共要装多少软件啊！不过要是不需要额外的功能，就能少装些依赖软件，而且可能有些软件已经被安装了。这里只演示下 netcdf 和 hdf5 的安装，其他软件装起来也差不多。当然，假设你和我一样，已经把 netcdf 和 hdf5 的依赖软件装好了。<br>我们先装 hdf5，下载源码后的操作大致是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@Dell Downloads]# tar -xvzf hdf5-1.8.13.tar.gz &gt; /dev/null</span><br><span class="line">[root@Dell Downloads]# cd hdf5-1.8.13/</span><br><span class="line">[root@Dell hdf5-1.8.13]# mkdir -p /opt/hdf5/hdf5-1.8.13</span><br><span class="line">[root@Dell hdf5-1.8.13]# ./configure --prefix=/opt/hdf5/hdf5-1.8.13 &gt; config.output 2&gt;&amp;1</span><br><span class="line">[root@Dell hdf5-1.8.13]# make all install &gt; make.output 2&gt;&amp;1</span><br><span class="line">[root@Dell hdf5-1.8.13]# ls /opt/hdf5/hdf5-1.8.13/</span><br><span class="line">bin  include  lib  share</span><br></pre></td></tr></table></figure></p>
<p>然后装 netcdf，其过程则是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@Dell netcdf]# tar -xvzf netcdf-4.4.0.tar.gz &gt; /dev/null</span><br><span class="line">[root@Dell netcdf]# cd netcdf-4.4.0/</span><br><span class="line">[root@Dell netcdf-4.4.0]# mkdir -p /opt/netcdf/netcdf-4.4.0</span><br><span class="line">[root@Dell netcdf-4.4.0]# CC=gcc FC=gfortran CPPFLAGS=-I/opt/hdf5/hdf5-1.8.13/include LDFLAGS=-L/opt/hdf5/hdf5-1.8.13/lib ./configure --prefix=/opt/netcdf/netcdf-4.4.0 &gt; config.output 2&gt;&amp;1</span><br><span class="line">[root@Dell netcdf-4.4.0]# make all install &gt; make.output 2&gt;&amp;1</span><br><span class="line">[root@Dell netcdf-4.4.0]# ls /opt/netcdf/netcdf-4.4.0/</span><br><span class="line">bin  include  lib  share</span><br></pre></td></tr></table></figure></p>
<p>楼上是安装 C 库，楼下开始安装 Fortran 库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@Dell netcdf]# tar -xvzf netcdf-fortran-4.4.0.tar.gz &gt; /dev/null</span><br><span class="line">[root@Dell netcdf]# cd netcdf-fortran-4.4.0/</span><br><span class="line">[root@Dell netcdf-fortran-4.4.0]# mkdir -p /opt/netcdf/netcdf-fortran-4.4.0</span><br><span class="line">[root@Dell netcdf-fortran-4.4.0]# CC=gcc FC=gfortran CPPFLAGS=-I/opt/netcdf/netcdf-4.4.0/include LDFLAGS=-L/opt/netcdf/netcdf-4.4.0/lib ./configure --prefix=/opt/netcdf/netcdf-fortran-4.4.0 &gt; config.output 2&gt;&amp;1</span><br><span class="line">[root@Dell netcdf-fortran-4.4.0]# make all install &gt; make.output 2&gt;&amp;1</span><br><span class="line">[root@Dell netcdf-fortran-4.4.0]# ls /opt/netcdf/netcdf-fortran-4.4.0/</span><br><span class="line">bin  include  lib  share</span><br></pre></td></tr></table></figure></p>
<p>安装过程中使用的是 root 权限，因为我要装在 <code>/opt</code> 这个目录下。我这里多次使用了重定向，像 <code>tar</code>、<code>configure</code>、<code>make</code> 这些命令，都会有大量的屏幕输出，为了显示便捷，我通过重定向把这些屏幕输出“扔掉了”（即 <code>&gt; /dev/null</code>）或者保存成文件了（即 <code>&gt; config.out 2&gt;&amp;1</code> 和 <code>&gt; make.output 2&gt;&amp;1</code>）。另外，netcdf 在某个版本（4.2？）后将 C 库和 Fortran 库分离了，而且得先安装 C 库再安装 Fortran 库，就像我这里演示的一样。<br>安装 hdf5 和 netcdf 的过程差不多，先解压源码包，创建安装目录，利用 <code>configure</code> 进行配置（设置库的位置、软件安装位置等），利用 <code>make</code> 进行编译，然后就 OK 了。<code>configure</code> 时可以指定编译器，比如我这里指定为 <code>gcc</code> 和 <code>gfortran</code>，也可以不指定，那么软件会用默认编译器进行安装。安装软件时需要用到不少的外部库函数，其中大部分存放在 <code>/usr/lib</code>、<code>/usr/local/lib</code>（或 <code>/usrlib64</code>、<code>/usrlocal/lib64</code>）里面，这些库可以自动被系统识别到。个别的库则需要我们在 <code>configure</code> 时进行设置，比如装 netcdf 的 C 库时加上了 hdf5 的路径，装 netcdf 的 Fortran 库时又加上了刚装的 netcdf 的 C 库，装 hdf5 时则不需要额外的库路径。那 <code>configure</code> 时要加的库到底有哪些呢？不同的软件明显是不同的 ，你可以在软件的 <code>README</code> 或 <code>INSTALL</code> 文件里进行查看。要是你懒得看，啥都不加也行啊，如果它报错说缺少库了，根据错误信息就能知道要加哪些库。嗯，也许一开始会让人有混乱感，但多装几个不同的软件以后慢慢就会熟悉的。<br>好了，等装好几个必要的软件以后，我们开始安装 NCL。首先需要预先测试下你的系统是否可以安装 NCL，并得到适合你机器的环境文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@Dell ncl]# tar -xvzf ncl_ncarg-6.3.0.tar.gz &gt; /dev/null</span><br><span class="line">[root@Dell ncl]# cd ncl_ncarg-6.3.0/</span><br><span class="line">[root@Dell ncl_ncarg-6.3.0]# mkdir -p /opt/ncl/ncl-6.3.0</span><br><span class="line">[root@Dell ncl_ncarg-6.3.0]# cd config/</span><br><span class="line">[root@Dell config]# make -f Makefile.ini</span><br><span class="line">cc -O   -c -o ymake-filter.o ymake-filter.c</span><br><span class="line">cc -O -o ymake-filter ymake-filter.o</span><br><span class="line">[root@Dell config]# ./ymake -config `pwd`</span><br><span class="line">[root@Dell config]# grep SYSTEM_INCLUDE Makefile</span><br><span class="line">SYSTEM_INCLUDE          = &quot;LINUX&quot;</span><br><span class="line">[root@Dell config]# ls LINUX*</span><br><span class="line">LINUX         LINUX.64.INTEL  LINUX.GNU         LINUX.INTEL      LINUX.ppc64.xl</span><br><span class="line">LINUX.32.PGI  LINUX.64.PGI    LINUX.IA64        LINUX.PGI</span><br><span class="line">LINUX.64.GNU  LINUX_alpha     LINUX.IA64.INTEL  LINUX.ppc32.GNU</span><br><span class="line">[root@Dell config]# vi LINUX.64.GNU</span><br><span class="line">[root@Dell config]# cp LINUX.64.GNU LINUX</span><br><span class="line">cp: overwrite &apos;LINUX&apos;? y</span><br></pre></td></tr></table></figure></p>
<p><code>ymake</code> 用来检测环境，可以看到没有错误提示。<code>grep</code> 的结果则告诉我们，待会 <code>configure</code> 时会用到 <code>LINUX</code> 这个环境文件，我们需要对它进行修改（改一改编译器、编译选项、库路径什么的）。不过这里我们可以用 <code>LINUX.64.GNU</code> 这个 template，用它覆盖掉 <code>LINUX</code> 就行了。当然，使用 <code>LINUX.64.GNU</code> 这个文件说明我所用编译器为 <code>gcc</code> 和 <code>gfortran</code>，如果你想用 intel 的编译器 <code>icc</code>、<code>ifort</code> 来编译，可以考虑使用 <code>LINUX.64.INTEL</code>。<br>好了，接下来就 <code>configure</code> 吧，然后你会发现，NCL 看起来更加友好一些：<br><img src="/2017/08/21/06climate-linux-intro-5/pic_3.png" alt="pic_3.png" title=""><br>是的，你直接运行 <code>configure</code>，它会交互式地让你输入相关信息，不用像装 netcdf 那样要一次性敲一长串字符，而且看起来更容易理解。当然了，其中有很多选项，而有些选项是需要额外库的，如果你确实需要某些功能，那就得先装好所需的库。嗯，还有就是，别把安装路径和库路径输错了。<br>安装路径：<br><img src="/2017/08/21/06climate-linux-intro-5/pic_4.png" alt="pic_4.png" title=""><br>库路径：<br><img src="/2017/08/21/06climate-linux-intro-5/pic_5.png" alt="pic_5.png" title=""><br><code>configure</code> 结束以后，<code>make</code> 一下就完事儿啦！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Dell ncl_ncarg-6.3.0]# make Everything &gt; make.output 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>噢，当然，别忘记在 <code>.bashrc</code> 里面设置环境变量了！（这里可以看到我给 netcdf 和 hdf5 也进行了设置）<br><img src="/2017/08/21/06climate-linux-intro-5/pic_6.png" alt="pic_6.png" title=""><br>不知道你看到这感觉怎样？不简单？太容易？我的感觉是：这一段写得我好累啊…</p>
<h1 id="软件包管理器"><a href="#软件包管理器" class="headerlink" title="软件包管理器"></a>软件包管理器</h1><p>嗯，感觉源码安装还是太麻烦，可是 binaries 又不能用？不妨这样想想，某个人也在用 Fedora，而且他已经源码装过 NCL 了，那他直接把编译好的拷给我是不是就能用了？咳咳，这个想法是不错，就算官网没有合适的，那找同系统且装过 NCL 的人拷贝呗。不过，是不是我还是得装一下 NCL 的依赖软件？好吧，这其实是一种比较粗略的想法。<br>好了，正式的来说，我们需要使用软件包管理器。先提一下 Linux 两大主流的软件包管理器，一个是 Fedora、CentOS、Red Hat 等使用的 RPM，另一个是 Debian、Ubuntu 等使用的 DPKG，后面的内容主要谈论 RPM（因为我是 Fedora 系统）。软件包管理器需要解决的即为 binaries 所无法满足的，即不同系统、不同环境的问题。首先，Fedora 和 CentOS 虽然是不同系统，但它们都采用 RPM 的包管理机制，一个 rpm 软件包当然既可以在 Fedora 下也可以在 CentOS 下安装了。其次，环境问题即为是否已经装有依赖软件，而 rpm 包大概相当于 binaries 加上环境检测脚本，它会先自动检测依赖性问题，不满足则不会安装，并且告诉你需要的依赖软件。虽说我们还是得装好几个其他的软件，但依赖软件也通过 RPM 安装不就行了，不用编译源码还是比较省事的。RPM 安装过程非常简单，比如我装一个 Google Chrome：<br><img src="/2017/08/21/06climate-linux-intro-5/pic_7.png" alt="pic_7.png" title=""><br>使用 <code>rpm</code> 命令就行了，<code>-i</code> 表示安装，<code>-v</code> 表示显示详细信息，<code>-h</code> 表示显示安装进度，<code>-q</code> 则查找是否安装了某个包。从显示的内容可以看出，我已经装过 Chrome 了。这里我就不再为了演示而把我的 Chrome 卸载重装了。<br>使用 RPM 是不是容易多了？毕竟不用自己编译。但还有更简单的方式，那就是使用 <code>yum</code> 命令。<code>yum</code> 可以自动帮你查找依赖软件然后一并安装。比如我用 <code>yum</code> 安装 NCL：<br><img src="/2017/08/21/06climate-linux-intro-5/pic_8.png" alt="pic_8.png" title=""><br><img src="/2017/08/21/06climate-linux-intro-5/pic_9.png" alt="pic_9.png" title=""><br>一条命令，它会自行解决依赖问题，确认后就连 NCL 带依赖软件一起装好了……啊呸，你咋不早说啊？前面源码装了这么久的 NCL，还出错好多次，现在告诉我就一条命令？好吧，我承认 <code>yum</code> 很好用，平时软件都是这么装的，也推荐你这样做。不过 <code>rpm</code> 和 <code>yum</code> 也不是万能的，不一定存在你要的软件包，就好比是“你并没有找到那个和你同系统且装了 NCL 的人”。其实我去年尝试用 <code>yum</code> 装 NCL 时就说找不到这样的软件包，所以我第一次装 NCL 就是实实在在的源码安装。还有一个问题就是版本的问题，我用 <code>yum</code> 只能装到6.1.2版的 NCL，而源码安装就能随便选择版本了。<br>对了，关于 <code>yum</code> 的使用，我也有困惑的地方，那就是软件包的名字。比如 NCL 的包的名字是 <code>ncl</code>，而我之前尝试用 <code>yum</code> 安装过 Google Chrome，我输 <code>yum install chrome</code> 或者 <code>yum install google-chrome</code>，它都说找不到这个软件。Chrome 这么大众的软件，怎么可能没有啊，实际上要这样输才行：<code>yum install google-chrome-stable</code>。嗯，也许猜不到软件包名称的时候应该 Google 一下。还有另一个经验要分享一下，如果你要用 <code>yum</code>，记得有个叫 <code>-devel</code> 的后缀，很多情况下有这个后缀的包才有头文件。比如 <code>yum install netcdf</code> 得到的只有库文件，你得再 <code>yum install netcdf-devel</code> 才能把头文件也装上。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Linux 软件千千万，安装方式两三种。对于你，也许是用的 Ubuntu 的 <code>apt-get</code>，也许更喜欢源码？！看你心情咯～最后预告一下，下一期要开始调模式了。很显然，这个只能是源码安装！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 入门教程——编写程序]]></title>
      <url>http://nearsc.github.io/2017/08/21/06climate-linux-intro-4/</url>
      <content type="html"><![CDATA[<p>气象家园投稿第四篇：编写程序</p>
<a id="more"></a>
<p>说起编程，平时我们都是写什么样的程序呢？算个平均、求个趋势，再检验下显著性？或者进行小波分析、EOF 分析？不知道大家的选择如何，反正我平时大多是靠 Matlab 来完成的，感觉二爷教的东西更有用啊喂！当然也有需要用到 Fortran 进行计算的，但谁会跑到 Linux 上写代码啊，在 Windows 下方便多了嘛！<br>不过呢，气象上用到的很多模式都需要在 Linux 的环境下运行，了解一些基本的 Linux 编程还是很有用的。模式的使用并不需要有很深的计算机知识，通常按照说明敲几行命令，说不定就 run 起来了。不过很多情况下还需要根据你的系统环境进行配置，有时甚至出现莫名其妙的问题而运行不了，这时候若是能对 Linux 编程略知一二，可能就帮了你的大忙了。这一期我会介绍一些有关 Linux 编程的基本知识，也稍微提一下 Makefile，但更多的内容还需要自己深入学习，相信大家不用多久就能成为模式小能手呢！那么第一步就从 <code>hello world</code> 开始吧！</p>
<h1 id="开始编译吧！"><a href="#开始编译吧！" class="headerlink" title="开始编译吧！"></a>开始编译吧！</h1><p>在 Linux 下，我们用 vi 照样写代码，但写好的代码如何编译呢？Windwos 下只需要一个按钮就行，Linux 下可以用一行命令来实现。<code>hello world</code> 的代码我就不贴了，但编译命令是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell hello]$ ifort -o hello hello.f90</span><br></pre></td></tr></table></figure></p>
<p>这里我的 Linux 装的是 Intel 的 Fortran 编译器，如果你想在你的 Linux 上编译 <code>hello.f90</code>，得看看你那的 Fortran 编译器是啥，然后把这里的 <code>ifort</code> 改成你的编译器的名称就行了。<code>-o hello</code> 会指定可执行文件名为 <code>hello</code>，你也可以改成 <code>-o myhello”，而后面跟的hello.f90则是将要编译的源码文件。若是不指定-o，写成“ifort hello.f90</code>，就会得到名为 <code>a.out</code> 的可执行文件。或许你的编译器是 gfortran？那就输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell hello]$ gfortran -o hello hello.f90</span><br></pre></td></tr></table></figure></p>
<p>除了 <code>-o</code> 选项，还有 <code>-O</code>、<code>-O2</code>、<code>-O3</code>，这些“杠大欧”们会对你的程序进行优化，貌似很多数值模式都考虑把它给加上，以提高运算效率。还有更多的参数，若是需要用到就 <code>man</code> 一下吧。如果你没有 Fortran 编译器（很有可能是这样），那么你可以去 Intel 官网下一个，他们有提供教育版的，安装过程也很方便。对了，我记得气象家园上有分享过来着。</p>
<h1 id="加入函数库"><a href="#加入函数库" class="headerlink" title="加入函数库"></a>加入函数库</h1><p>为什么需要加入函数库呢？简而言之，外部函数库的功能就是帮助你完成一些 Fortran 本身无法完成的工作，比如读写 nc 文件、进行并行计算等等。通常下载安装完一个函数库以后，会得到一些库文件和头文件分别存放在 <code>lib</code> 和 <code>include</code> 文件夹下，以 netcdf 库（读写 nc 文件的库）为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ ls /opt/netcdf/netcdf-latest/lib/</span><br><span class="line">libnetcdf.a    libnetcdff.so        libnetcdf.la        libnetcdf.so.11</span><br><span class="line">libnetcdff.a   libnetcdff.so.6      libnetcdf.settings  libnetcdf.so.11.0.0</span><br><span class="line">libnetcdff.la  libnetcdff.so.6.0.1  libnetcdf.so        pkgconfig</span><br><span class="line">[N@Dell ~]$ ls /opt/netcdf/netcdf-latest/include/</span><br><span class="line">netcdf4_f03.mod                 netcdf.h       netcdf_nc_data.mod</span><br><span class="line">netcdf4_nc_interfaces.mod       netcdf.inc     netcdf_nc_interfaces.mod</span><br><span class="line">netcdf4_nf_interfaces.mod       netcdf_mem.h   netcdf_nf_data.mod</span><br><span class="line">netcdf_f03.mod                  netcdf_meta.h  netcdf_nf_interfaces.mod</span><br><span class="line">netcdf_fortv2_c_interfaces.mod  netcdf.mod     typesizes.mod</span><br></pre></td></tr></table></figure></p>
<p>那么如何使用 netcdf 库呢？首先需要在源代码里面 <code>use netcdf</code>，然后调用 netcdf 库函数进行读取。而在编译的时候则需要把库的名称和路径告诉编译器，即编译时加上几个参数。这里提供一个示例程序：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">  <span class="keyword">use</span> netcdf</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">character</span>(<span class="number">50</span>) :: ncfile</span><br><span class="line">  <span class="keyword">integer</span> :: fid, varid, stat, year, recnum, start_num</span><br><span class="line">  <span class="keyword">integer</span> :: i</span><br><span class="line">  <span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>), <span class="keyword">dimension</span>(<span class="number">200</span>) :: ice</span><br><span class="line">  <span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>), <span class="keyword">dimension</span>(<span class="number">180</span>) :: lat</span><br><span class="line">  <span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>), <span class="keyword">dimension</span>(<span class="number">360</span>) :: lon</span><br><span class="line"><span class="comment">!初始化</span></span><br><span class="line">  ncfile=<span class="string">'HadISST_ice.nc'</span></span><br><span class="line">  year=<span class="number">1979</span></span><br><span class="line">  recnum=<span class="number">12</span></span><br><span class="line">  start_num=(year-<span class="number">1870</span>)*<span class="number">12</span>+<span class="number">1</span></span><br><span class="line"><span class="comment">!打开文件，读取数据</span></span><br><span class="line">  stat=nf90_open(ncfile, NF90_NOWRITE, fid)</span><br><span class="line">  stat=nf90_inq_varid(fid, <span class="string">'sic'</span>, varid)</span><br><span class="line">  stat=nf90_get_var(fid, varid, ice, start=(/<span class="number">180</span>,<span class="number">10</span>,start_num/), <span class="built_in">count</span>=(/<span class="number">1</span>,<span class="number">1</span>,recnum/))</span><br><span class="line">  stat=nf90_inq_varid(fid, <span class="string">'latitude'</span>, varid)</span><br><span class="line">  stat=nf90_get_var(fid, varid, lat)</span><br><span class="line">  stat=nf90_inq_varid(fid, <span class="string">'longitude'</span>, varid)</span><br><span class="line">  stat=nf90_get_var(fid, varid, lon)</span><br><span class="line">  stat=nf90_close(fid)</span><br><span class="line"><span class="comment">!输出到屏幕</span></span><br><span class="line">  <span class="built_in">write</span>(*,*)<span class="string">'  lat= '</span>, lat(<span class="number">10</span>), <span class="string">'  lon= '</span>, lon(<span class="number">180</span>)</span><br><span class="line">  <span class="keyword">do</span> i=<span class="number">1</span>,recnum</span><br><span class="line">    <span class="built_in">write</span>(*,*)ice(i)</span><br><span class="line">  <span class="keyword">enddo</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> main</span><br></pre></td></tr></table></figure></p>
<p>源码就不作过多说明了，我们来看看编译命令及运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell readnc]$ ifort -o readnc readnc.f90 -lnetcdff -I/opt/netcdf/netcdf-latest/include -L/opt/netcdf/netcdf-latest/lib</span><br><span class="line">[N@Dell readnc]$ ./readnc </span><br><span class="line">   lat=    80.5000000000000        lon=  -0.500000000000000     </span><br><span class="line">  0.920000016689301     </span><br><span class="line">  0.959999978542328     </span><br><span class="line">  0.850000023841858     </span><br><span class="line">  0.959999978542328     </span><br><span class="line">  0.870000004768372     </span><br><span class="line">  0.910000026226044     </span><br><span class="line">  0.680000007152557     </span><br><span class="line">  0.589999973773956     </span><br><span class="line">  0.259999990463257     </span><br><span class="line">  0.560000002384186     </span><br><span class="line">  0.720000028610229     </span><br><span class="line">  0.750000000000000</span><br></pre></td></tr></table></figure></p>
<p>编译的命令和之前相比多了三项。<code>-lnetcdff</code> 可以看成是 <code>-l</code> 和 <code>netcdff</code> 连在一起，其中的 <code>-l</code> 是 lib 的意思，<code>netcdff</code> 为库名，表示你将用到的库文件名为 <code>libnetcdff.so</code> 或 <code>libnetcdff.a</code>。库文件的位置由 <code>-L</code> 后的路径给出，头文件则从 <code>-I</code> 后的路径里去找。使用其他库时，也是类似地加上 <code>-lxxx -Ixxx -Lxxx</code>，然后就能正确调用外部函数了。当然，你可以加上多个 <code>-l</code>、<code>-I</code> 以及 <code>-L</code>。也许你也想读个 nc 文件试试，却发现没有 netcdf 库？等下载好了却装不成功？那就百度一下吧，或者参考下一期的内容。</p>
<h1 id="so-a-o文件"><a href="#so-a-o文件" class="headerlink" title=".so / .a / .o文件"></a>.so / .a / .o文件</h1><p>有人可能会问了，<code>xxx.so</code> 文件和 <code>xxx.a</code> 文件有啥区别啊，其实前者是动态函数库，而后者是静态函数库。两者的区别之一在于，是否需要从库文件中读取函数信息。对于静态函数库，它在编译的时候就直接整合到可执行文件中了，程序可以独立运行的，不需要再读 <code>xxx.a</code> 的内容。若是使用了动态函数库，可执行文件运行时还得去 <code>xxx.so</code> 里面读取函数。形象点描述的话，静态函数库是揣兜里的，随时可以使用，而动态函数是人家的，要用的时候还得找人家拿来看看。<br>也许你就要问了，前面使用 netcdf 库编译时加的是 <code>-lnetcdff</code>，可我们并不知道它到底用的 <code>libnetcdff.so</code> 还是 <code>libnetcdff.a</code> 啊？要知道，在 <code>/opt/netcdf/netcdf-latest/lib</code> 目录下，这两个文件可都是存在的！实际上我们可以不使用 <code>-l</code> 和 <code>-L</code> 的组合，而是这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell readnc]$ ifort -o readnc readnc.f90 /opt/netcdf/netcdf-latest/lib/libnetcdff.so -I/opt/netcdf/netcdf-latest/include</span><br><span class="line">[N@Dell readnc]$ ifort -o readnc readnc.f90 /opt/netcdf/netcdf-latest/lib/libnetcdff.a -I/opt/netcdf/netcdf-latest/include &gt; ifort.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>可以看到使用 <code>libnetcdff.so</code> 时，编译没有问题。而使用 <code>libnetcdff.a</code> 时则会出错，这里我将标准输出和标准错误输出都重定向了，不了解重定向没有关系，总之就是我把编译错误的信息放到 <code>ifort.log</code> 文件里了。当然我们不用查看 <code>ifort.log</code>，只需知道使用 <code>libnetcdff.a</code> 时确实出错了，也说明之前采用 <code>-l</code> 与 <code>-L</code> 组合时，实际是用了 <code>libnetcdff.so</code> 文件。至于为什么不能用静态库编译呢？大概是还需要其他函数库，而 <code>libnetcdff.so</code> 里有它们的信息但 <code>libnetcdff.a</code> 里面却没有吧。<br>那么我们来看另一个有关动态库的问题。还是以 netcdf 库为例，之前我们能够正常编译运行，但现在我把 <code>.bashrc</code> 文件里的某行注释掉（图中 <code>netcdf</code> 部分的 <code>export LD_LIBRARY_PATH=…</code> 那行）：<br><img src="/2017/08/21/06climate-linux-intro-4/pic_1.png" alt="pic_1.png" title=""><br>那么当我重新登录的时候，就会显示这样的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell readnc]$ ifort -o readnc readnc.f90 -lnetcdff -I/opt/netcdf/netcdf-latest/include -L/opt/netcdf/netcdf-latest/lib</span><br><span class="line">[N@Dell readnc]$ ./readnc </span><br><span class="line">./readnc: error while loading shared libraries: libnetcdff.so.6: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>为什么呢？编译没错，却不能运行？那是因为我们编译时用的动态库，运行时就得再次访问 <code>libnetcdff.so</code> 文件，而程序需要由 <code>LD_LIBRARY_PATH</code> 这个环境变量提供动态库文件所在的位置。这样就懂了吧？注释掉那行就意味着程序再也找不着 <code>libnetcdff.so</code> 了。<br>动态库和静态库有各自的优点，动态库用起来方便一点，静态库独立一些。前面说过用 <code>libnetcdff.a</code> 编译时，因为缺少其他函数库的信息失败了，而 <code>libnetcdff.so</code> 则含有那些函数库的信息，<code>ldd libnetcdff.so</code> 就能看到。另一方面，动态库升级后不需要重新编译可执行文件，而静态库升级后需要重新编译才能使用新函数。不过，使用静态库的好处在于，编译得到的程序可以独立执行，不再需要访问库文件了。<br>这里我再稍微介绍下怎样生成 <code>.a</code> 及 <code>.so</code> 文件。不过先要提一下 <code>.o</code> 文件，即目标文件，相信大家都见过。以 <code>hello world</code> 为例，如果编译命令这样写，就会生成 <code>.o</code> 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell hello]$ ifort -c hello.f90</span><br><span class="line">[N@Dell hello]$ ifort -o hello hello.o </span><br><span class="line">[N@Dell hello]$ ls</span><br><span class="line">hello  hello.f90  hello.o</span><br></pre></td></tr></table></figure></p>
<p>反而多敲了一行，为什么一定要生成 <code>.o</code> 文件呢？其实静态库就是将很多 <code>.o</code> 和在一起形成的，动态库也差不多，有了库文件就能多次使用而不用每次都编译了。那如何形成库文件呢？这里我用另一个程序来演示一下，和 <code>hello world</code> 不同，它有三个源码文件。先不管我这个程序是做什么用的，只看看我是如何编译的吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell test]$ ls</span><br><span class="line">main.c  main.h  solve_x.c  solve_x.h  solve_y.c  solve_y.h</span><br><span class="line">[N@Dell test]$ mpicc -c solve_x.c</span><br><span class="line">[N@Dell test]$ mpicc -c solve_y.c</span><br><span class="line">[N@Dell test]$ ar -r libsolve.a solve_x.o solve_y.o </span><br><span class="line">ar: creating libsolve.a</span><br><span class="line">[N@Dell test]$ mpicc -o solve main.c libsolve.a </span><br><span class="line">[N@Dell test]$ mpirun -n 2 ./solve</span><br><span class="line">Proc 0: x=1.994085,	ex=0.000035,	step=11</span><br><span class="line">Proc 1: y=1.999241,	ey=0.000002,	step=11</span><br></pre></td></tr></table></figure></p>
<p>这个程序是用 c 语言写的，还用到了并行，因此编译器是 mpicc，且运行时需要写成 <code>mpirun -n 2 ./solve</code>，但它跟普通的串行程序看起来区别不大。可以看到我先编译了 <code>solve_x.c</code> 和 <code>solve_y.c</code>，得到目标文件后把它们合成一个 <code>libsolve.a</code>，建立了自己的一个函数库。然后编译 <code>main.c</code> 时直接就用这个静态库了，最后执行 <code>solve</code>。如果考虑制作动态函数库，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell test]$ ls</span><br><span class="line">main.c  main.h  solve_x.c  solve_x.h  solve_y.c  solve_y.h</span><br><span class="line">[N@Dell test]$ mpicc -fPIC -shared -o libsolve.so solve_x.c solve_y.c</span><br><span class="line">[N@Dell test]$ mpicc -o solve main.c libsolve.so </span><br><span class="line">[N@Dell test]$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</span><br><span class="line">[N@Dell test]$ mpirun -n 2 ./solve</span><br><span class="line">Proc 0: x=1.994085,	ex=0.000035,	step=11</span><br><span class="line">Proc 1: y=1.999241,	ey=0.000002,	step=11</span><br></pre></td></tr></table></figure></p>
<p>其过程和静态库生成差不太多，只是出现了 <code>-fPIC</code> 和 <code>-shared</code> 选项，同时还需要设置 <code>LD_LIBRARY_PATH</code>。相信大家百度一下 man 一下大致就懂，这里不再赘述。</p>
<h1 id="如何调试？"><a href="#如何调试？" class="headerlink" title="如何调试？"></a>如何调试？</h1><p>Windows 下程序调试大家都会，编译器自带该功能。而 Linux 下可以用 GDB 来进行调试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell readnc]$ ifort -g -o readnc readnc.f90 -lnetcdff -I/opt/netcdf/netcdf-latest/include -L/opt/netcdf/netcdf-latest/lib</span><br><span class="line">[N@Dell readnc]$ gdb readnc</span><br></pre></td></tr></table></figure></p>
<p>你会发现编译的时候多加了一个参数 <code>-g</code>，然后你才能用 <code>gdb readnc</code> 进行调试。说实话我平时在 Linux 下几乎不用 GDB，但也许你会需要它，所以这里还是列一下 GDB 的基本操作：<br><code>file [filename]</code>：打开可执行文件 filename<br><code>info</code>：查看相关信息，如 <code>info breakpoints</code> 查看所有断点<br><code>list</code>：列出可执行文件对应的代码<br><code>break</code>：设置断点，一般按源文件行号来设置，如 <code>break 5</code><br><code>delete</code>：按断点号删除断点<br><code>clear</code>：按行号删除断点<br><code>run</code>：运行可执行文件<br><code>continue</code>：从断点处继续执行<br><code>next</code>：单步执行<br><code>print</code>：显示变量或表达式的值<br><code>whatis</code>：查看变量类型<br><code>kill</code>：终止正在调试的程序<br><code>quit</code>：退出 GDB<br>大致就是这些，我就不演示了，用一用就熟悉啦！</p>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>Makefile 是啥？为什么要使用它呢？想象一下你有个程序是由100个源文件编译链接而成，那我岂不是要敲很长的命令？若要重新编译，我还得再敲一遍？当然不是，我们可以把编译信息写到一个文件里，即 Makefile，然后敲入命令 <code>make</code> 就行了！而且当你改动了一些源码文件后再次编译时，<code>make</code> 还能够自动识别修改了哪些文件并只编译那些文件，这样可以节省不少时间。还是以 <code>solve</code> 程序为例来演示下 Makefile 的基本规则吧，我写的 Makefile 文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CC = mpicc</span><br><span class="line"></span><br><span class="line">solve: main.o solve_x.o solve_y.o</span><br><span class="line">        $&#123;CC&#125; -o solve main.o solve_x.o solve_y.o</span><br><span class="line">main.o: main.c</span><br><span class="line">        $&#123;CC&#125; -c main.c</span><br><span class="line">solve_x.o: solve_x.c</span><br><span class="line">        $&#123;CC&#125; -c solve_x.c</span><br><span class="line">solve_y.o: solve_y.c</span><br><span class="line">        $&#123;CC&#125; -c solve_y.c</span><br><span class="line">clean:</span><br><span class="line">        rm -f solve main.o solve_x.o solve_y.o</span><br></pre></td></tr></table></figure></p>
<p>其中第一行为定义变量，这里我把编译器定为 <code>mpicc</code>，如果想换另一个编译器，只需要修改第一行。后面的内容则以这样的形式书写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: object files</span><br><span class="line">[tab] command</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>target</code> 为目标文件或标签，后面的 <code>object files</code> 为完成该 <code>target</code> 所需要用到的文件，两者以冒号隔开。第二行以 <code>tab</code> 键开头，后面紧跟完成该 <code>target</code> 的具体命令。这里共有5个 <code>target</code>，前四个分别生成 <code>solve</code>、<code>main.o</code>、<code>solve_x.o</code>、<code>solve_y.o</code>，最后一个是把这四个文件删除。如果你要执行某一条 <code>target</code>，可以敲入 <code>make target</code>，比如这样的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell test]$ ls</span><br><span class="line">libsolve.a   main.c  Makefile   solve_x.h  solve_y.h</span><br><span class="line">libsolve.so  main.h  solve_x.c  solve_y.c</span><br><span class="line">[N@Dell test]$ make solve_x.o </span><br><span class="line">mpicc -c solve_x.c</span><br><span class="line">[N@Dell test]$ make solve</span><br><span class="line">mpicc -c main.c</span><br><span class="line">mpicc -c solve_y.c</span><br><span class="line">mpicc -o solve main.o solve_x.o solve_y.o</span><br><span class="line">[N@Dell test]$ make clean</span><br><span class="line">rm -f solve main.o solve_x.o solve_y.o</span><br></pre></td></tr></table></figure></p>
<p>当我们需要实现 <code>solve_x.o</code> 这个 <code>target</code> 的时候，它将 <code>solve_x.c</code> 编译成了 <code>solve_x.o</code>。实现 <code>solve</code> 这个 <code>target</code> 时，需要用到 <code>main.o</code>、<code>solve_x.o</code>、<code>solve_y.o</code> 三个文件，而 <code>main.o</code> 和 <code>solve_y.o</code> 并不存在，此时 <code>make</code> 就会先编译得到 <code>main.o</code> 与 <code>solve_y.o</code>，然后再得到 <code>solve</code>。如果你直接敲 <code>make</code>，那就会自动完成第一个目标。如果你要 <code>make</code> 的文件不叫 <code>Makefile</code>，而叫 <code>MyMakefile</code>，那就敲 <code>make –f MyMakefile</code>。<br>其实随便找一个模式看看，就发现它们基本都是采用 <code>make</code>（或者 <code>gmake</code>？）进行编译，因为源文件实在是太多了。不过模式的 Makefile 是很复杂的，我也看不太明白，但我知道它大致在干嘛，然后改一下关键的地方，嗯，编译通过啦！</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Linux 下写程序对于习惯了 Windows 的我们来说确实需要一段时间适应，适应了就一切都手到擒来。不过 Linux 编程的知识多了去了，我也有很多不懂的地方，真的是需要不断地学习啊！好了，这期就这样啦，我们下期见！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 入门教程——vi 与环境变量]]></title>
      <url>http://nearsc.github.io/2017/08/19/06climate-linux-intro-3/</url>
      <content type="html"><![CDATA[<p>气象家园投稿第三篇：vi 与环境变量</p>
<a id="more"></a>
<p>熟悉了 Linux 的一些基本操作以后，差不多就可以正式用它来进行工作了，那么平时主要在 Linux 上做些什么呢？根据自己的经历，我想大概有以下几点吧：</p>
<ol>
<li>管理文件（或者说管理系统？）</li>
<li>编写程序（应该大多是 Fortran 语言吧）</li>
<li>软件使用（如 NCL、Matlab）</li>
<li>模式使用（多在服务器上运行）<br>之后几篇的内容大致也就是关于这几个方面的。先说说管理文件，可以很简单，比如我备份几个数据、归类几个文件夹，就是对我的文件进行了管理；也可以相对更为复杂，比如我查看一下系统信息的文件，修改一下配置文件，使得我的系统用起来更加符合我自己的习惯。就泛泛地说“管理”这个词，它包含的内容是很多的，对于普通用户和管理员用户，“管理”又具有不同的含义。不过我可没法聊这些，但有必要介绍下文本编辑器，因为不知道怎么编辑文件，怎么能进行管理呢（点头</li>
</ol>
<h1 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h1><p>在 Linux 下，如果你想查看一个文本文件的内容，可以通过多种方式来实现。下面这5个命令均能查看文件内容：<code>cat</code>，<code>more</code>，<code>less</code>，<code>head</code>，<code>tail</code>。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ cat readme</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>cat</code> 会显示所有内容，<code>more</code> 和 <code>less</code> 是分页显示（区别在于 <code>more</code> 只能向下滚动而 <code>less</code> 可以上下滚动），<code>head</code> 显示开头部分，<code>tail</code> 显示结尾部分。具体用哪个命令在于你自己，不过有个常用的用法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell Temp]$ tail -f log</span><br></pre></td></tr></table></figure></p>
<p><code>tail</code> 会显示文件结尾部分的内容，而 <code>-f</code> 选项（或 <code>--follow</code>）会实时更新文件内容。意思就是，比如你在运行一段程序，该程序将一些信息写到文件 <code>log</code> 里面，如果只是 <code>tail log</code>，则会显示到该命令为止的 <code>log</code> 文件中的内容，而实际上你的程序还在不断写新信息到 <code>log</code> 里。使用 <code>-f</code> 选项让你可以一直看到新的信息，而不用每隔一段时间就敲一次 <code>tail log</code>。<br>但这5个命令只是查看文本文件的内容，并不能写东西到文件。这时就需要文本编辑器了，比如 vi，Emacs，nano 等等。我想介绍一下 vi，毕竟它有着不可撼动的地位，而且我也是用 <code>vi</code> 用习惯了，懒得去接触其他编辑器了（憨笑<br>先用 vi 打开已存在的文件，或者新建文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell Temp]$ vi new</span><br></pre></td></tr></table></figure></p>
<p>若 <code>new</code> 已存在，则会打开 <code>new</code> 这个文件，若 <code>new</code> 不存在，则新建一个文件名为 <code>new</code> 的文件。vi 一共有三种模式：一般模式、编辑模式、命令行模式。一般模式是刚打开文件后所进入的模式，可以进行移动光标、删除字符、复制粘贴等操作。在一般模式下若按下 <code>i</code>，<code>o</code>，<code>a</code> 等按键后将进入编辑模式，此时可以对文件内容自由编辑，按下 <code>Esc</code> 则退出到一般模式。在一般模式下若按下 <code>:</code>，<code>/</code>，<code>?</code> 等按键（<code>:</code> 即 <code>shift+;</code>），则进入到命令行模式，该模式下可以执行查找、替换、保存、退出等操作。下面简单列举下三种模式下的常用操作：<br>一般模式：<br><code>h</code>，<code>j</code>，<code>k</code>，<code>l</code> 或 <code>←</code>，<code>↓</code>，<code>↑</code>，<code>→</code>：光标的移动<br><code>[Ctrl]+f</code>，<code>[Ctrl]+b</code> 或 <code>[Page Down]</code>，<code>[Page Up]</code>：向下/向上翻页<br><code>0</code>，<code>$</code> 或 <code>[Home]</code>，<code>[End]</code>：行首/行尾<br><code>n[space]</code>：向右移动 n 个字符，[space] 为空格键<br><code>nG</code>：移动到第 n 行，只按 G 则移动到最后一行，gg（相当于 1G）为移动到第一行<br><code>n[Enter]</code>：向下移动 n 行<br><code>x</code>，<code>X</code>：向后/向前删除一个字符<br><code>dd</code>，<code>ndd</code>：删除当前行/向下删除 n 行<br><code>dw</code>：删除当前单词<br><code>yy</code>，<code>nyy</code>：复制当前行/向下复制 n 行<br><code>p</code>，<code>P</code>：将已复制的内容粘贴到光标的下一行/上一行<br><code>u</code>，<code>[Ctrl]+r</code>：撤销/恢复撤销<br><code>.</code>：重复上一个操作<br><code>v</code>，<code>V</code>，<code>[Ctrl]+v</code>：块选择，选取后用 y 和 d 来复制和删除<br>一般模式切换至编辑模式：<br><code>i</code>，<code>I</code>：插入模式，i 从当前光标插入，I 从行首插入<br><code>a</code>，<code>A</code>：插入模式，a 从当前光标前插入，A 从行尾插入<br><code>o</code>，<code>O</code>：插入模式，o 从下一行插入新行，O 从上一行插入新行<br><code>r</code>，<code>R</code>：替换字符，r 只替换一个字符，R 一直替换<br><code>cw</code>：替换单词，类似于 dw+i<br>命令行模式：<br><code>:w</code>，<code>:w!</code>：保存/强制保存<br><code>:q</code>，<code>:q!</code>：退出/退出但不保存<br><code>:wq</code>：保存且退出<br><code>:set nu</code>，<code>:set nonu</code>：显示行号/不显示行号<br><code>:!command</code>： 暂时离开 vi 执行命令 commad<br><code>:sh</code>，<code>[Ctrl]+d</code>：暂时离开 vi 执行多条命令，[Ctrl]+d 则回到 vi<br><code>/word</code>，<code>?word</code>：向下查找/向上查找<br><code>n</code>，<code>N</code>：进行查找后，寻找下一个/上一个匹配项<br><code>:n1,n2s/word1/word2/g</code>：在第 n1 和 n2 行间查找 word1，并替换成 word2<br><code>:n</code>，<code>:N</code>，<code>:files</code>：打开多个文件时（如 <code>vi file1 file2</code>），切换或显示不同的文件，<br>基本上常用到的就是这些了，更多的内容可以自己找找书上的内容，我这里列举的就当作是一个快速检索页面吧。当然你也可以自己学习 Emacs，不过总归是要学好一款编辑器的，有了它才能做很多事情啊，具体使用哪个编辑器就是你的自由啦！</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>相信大家应该接触过环境变量了，那就是 Windows 下安装 GrADS 时，最后需要 <code>set path</code>，才能正常使用。如果你还记得的话，就是在系统高级设置里面找到环境变量，然后在 <code>Path</code> 那个变量后面加上你装的 GrADS 的路径，这样你在 <code>cmd</code> 里面敲 <code>grads</code> 就可以运行它了。不过也许你还是不太了解什么叫环境变量？<br>总的来说 Linux 下的变量可分为环境变量和自定义变量。简而言之，自定义变量由用户定义，环境变量则由系统来定义。那变量有什么用呢？举个例子，当我们需要重复输入一个长路径的时候，可以通过自定义一个变量保存该路径，以达到减少输入量的目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ workdir=/home/N/Temp/solve_equation</span><br><span class="line">[N@Dell ~]$ cd $workdir</span><br><span class="line">[N@Dell solve_equation]$ pwd</span><br><span class="line">/home/N/Temp/solve_equation</span><br></pre></td></tr></table></figure></p>
<p>这里定义了变量 <code>workdir</code>，调用这个变量内容时需要用到 <code>$workdir</code> 或者 <code>${workdir}</code> 的形式。这样就不用每次输入一长串路径了。而环境变量，则是系统定义的一系列与操作环境有关的变量，在命令行敲入 <code>env</code> 即可查看所有环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell solve_equation]$ env</span><br></pre></td></tr></table></figure></p>
<p>当你使用 Linux 时，可能神不知鬼不觉地就用到了这些环境变量。我感觉其中关注较多的是 <code>PATH</code>，不过像 <code>HOME</code>、<code>SHELL</code>、<code>LANG</code>、<code>HISTSIZE</code> 和 <code>LD_LIBRARY_PATH</code> 等等也含有重要的信息啦，但这里重点要说的还是 <code>PATH</code> 以及 <code>.bashrc</code> 文件。对了，如果你想查看某个变量的值，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ echo $PATH</span><br></pre></td></tr></table></figure></p>
<h1 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h1><p>Windows 下不设置 <code>Path</code> 将无法在命令行直接运行 <code>grads</code>。Linux 也一样，实际上 <code>PATH</code> 这个变量包含了执行文件的查找路径。当你敲入某个命令如 <code>vi</code> 时，系统会在 <code>PATH</code> 提供的路径里去找，看是否存在 <code>vi</code> 这个程序。如果找不到，那就无法运行 vi 咯，你可以试试这样的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ export PATH=</span><br></pre></td></tr></table></figure></p>
<p>然后你会发现不能运行 <code>vi</code> 了，甚至连 <code>ls</code>、<code>cp</code> 等等也没用了，因为你的 <code>PATH</code> 没有值了，不过别急，重新打开终端就恢复了。<br>PS：一般设置自定义变量时直接写成 <code>var=...</code> 的形式，环境变量的修改则写成 <code>export var=...</code> 的形式。<br>简单来说，设置 <code>PATH</code> 使得你直接敲入命令名就能执行该命令，而不用敲命令的路径。前面将 <code>PATH</code> 设为空值以后，虽说敲 <code>vi</code> 没用，但你可以敲 <code>/usr/bin/vi</code> 啊！另一方面，你自己写了个 <code>hello</code>，你也可以把它的路径加到 <code>PATH</code> 里面，这样就能直接敲 <code>hello</code> 了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ export PATH=$PATH:/home/N/Temp</span><br><span class="line">[N@Dell ~]$ hello</span><br><span class="line"> Hello world!</span><br></pre></td></tr></table></figure></p>
<p>需要说明的是，<code>PATH</code> 里的路径是执行文件所在文件夹，这里我在 <code>PATH</code> 里加上 <code>/home/N/Temp</code> 后，<code>/home/N/Temp</code> 下的所有执行文件都可以通过直接敲入程序名的方式来执行了。你不能把路径直接写到程序名，比如这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ export PATH=$PATH:/home/N/Temp/hello</span><br><span class="line">[N@Dell ~]$ hello</span><br><span class="line">bash: hello: command not found...</span><br></pre></td></tr></table></figure></p>
<p>让我们来设想另一个情景，当我们使用服务器时，由于是多个用户在使用，服务器上装了很多的软件，但是并不是所有软件都是你需要的。实际情况是，管理员只是负责把软件装好，至于谁想用，那就把要用的软件的路径加到你的 <code>PATH</code> 里，这也意味着每个用户的 <code>PATH</code> 的内容是不同的。再比如，服务器上某个软件装了好几个版本，而你由于兼容性问题要用老版本的软件，那也得把 <code>PATH</code> 里面该软件的路径改为老版本的路径。</p>
<h1 id="bashrc文件"><a href="#bashrc文件" class="headerlink" title=".bashrc文件"></a>.bashrc文件</h1><p>另一个要说明的就是 <code>.bashrc</code> 文件了， <code>.bashrc</code> 文件相当于是“登录时自动设置”的脚本，免去了每次登录重新设置各种变量的麻烦。该文件位于用户家目录下（如 <code>/home/N/.bashrc</code>），其内容大致如下：<br><img src="/2017/08/19/06climate-linux-intro-3/pic_1.png" alt="pic_1.png" title=""><br>上一期提到过把 <code>hello</code> 的路径放到这个文件里，可以由程序名来直接运行程序。实际上是将前面提到的 <code>export PATH=$PATH:/home/N/Temp</code> 直接写到 <code>.bashrc</code> 文件中，这样就能在登录时自动设置 <code>PATH</code>，那么登录后就可以直接敲 <code>hello</code> 来运行它了。<br>在 <code>~/.bashrc</code> 文件里还可以对别名进行设置，即 <code>alias ...</code> 。这可是很好用的一个功能，只需要设置一个简称，就可以方便操作。在命令行下演示 <code>alias</code> 的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ alias &quot;hello=/home/N/Temp/hello&quot;</span><br><span class="line">[N@Dell ~]$ hello</span><br><span class="line"> Hello world!</span><br></pre></td></tr></table></figure></p>
<p>这里是通过设置 <code>alias</code> 来直接运行 <code>hello</code> 的，看起来设置 <code>alias</code> 和设置 <code>PATH</code> 差不多嘛！不过 <code>alias</code> 和 <code>PATH</code> 确实是两回事，起码后面的路径不相同（<code>alias</code> 是写出了 <code>hello</code> 的完整路径，<code>PATH</code> 里只写到文件夹），但最主要两者基本概念就不同，大家慢慢体会吧。<br>基本上 <code>.bashrc</code> 文件里就是设置 <code>alias</code> 和环境变量了吧，不过以后有什么特殊需求的话，也可能会在 <code>.bashrc</code> 里面写入其他的语句(如图中的 <code>ulimit ...</code>)。<br>对了，图里的 <code>source</code> 命令是啥？其实和 <code>export</code> 一样也是用来设置环境的，搜一下就懂咯~<br>有的机器上只有 <code>.kshrc</code> 没有 <code>.bashrc</code>？？那就修改 <code>.kshrc</code> 呗！</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这一期的内容其实涉及到 shell 及 shell script 的学习，不过它也挺复杂的，我只能从很浅的层面稍微介绍介绍。建议有时间可以多看看 shell 与 shell script 的内容，真的很重要！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 入门教程——基本操作与常用命令]]></title>
      <url>http://nearsc.github.io/2017/08/19/06climate-linux-intro-2/</url>
      <content type="html"><![CDATA[<p>气象家园投稿第二篇：基本操作与常用命令</p>
<a id="more"></a>
<p>上一期跟大家谈了谈我对 Linux 的一些个人感受，也讲了 Fedora 23 的安装过程，那么接下来就是关于“如何用好 Linux”的内容了。本期我将以“让初学者快速上手”为主要目标，介绍 Linux 下的基本操作与常用命令，分享一些我使用时的小经验，希望大家喜欢 :P</p>
<h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>下面的内容均在 Fedora 20 下进行示范，可能有的小伙伴已经安装了其他 Linux 发行版（如 Ubuntu、CentOS 等），但那并不会造成太大影响。<br>启动 Fedora 20 以后，进行用户登陆，之后弹出来一个桌面，看起来和 Windows 差不多嘛！正如上期所言，许多 Linux 发行版都具有图形界面，如果你想切换成字符界面，可以通过组合键 <code>Ctrl+Alt+F2~F6</code> 来实现。你可以直接就用字符界面来进行后面的操作，但若想使用图形界面（或许是因为你想一边放音乐一边练习命令），就需要把桌面提供的终端调出来，即在程序列表里面找类似 <code>Terminal</code> 的程序。当然我建议你上网搜一下，你所用系统里调出终端的快捷键是什么？如果你和我一样使用了 Fedora（桌面为 GNOME），那么需要自行设置快捷键 <code>Settings → Keyboard → Shortcuts → Custom Shortcuts → &#39;+&#39;</code>，如下图：<br><img src="/2017/08/19/06climate-linux-intro-2/pic_1.png" alt="pic_1.png" title=""><br>其中 Name 随意填写，Command 栏写上 <code>/usr/bin/gnome-terminal</code>。确定以后可以点击图中 <code>Terminal</code> 蓝色长条的右端，即可设置快捷键，我这里是 <code>Super+T</code>，Super 即 Windows 键。不管你是用的是字符界面，还是桌面下的终端，接下来就开始进行一些简单的操作吧！</p>
<p>进入终端（或字符界面）以后，会出现类似下面的命令提示行，意思是用户 N 在计算机 Dell 上登录了，当前路径是~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$</span><br></pre></td></tr></table></figure></p>
<p>以前 Windows 下从“我的电脑”（即文件浏览器）中查看文件，新建文件夹，复制、移动文件等，现在均以在终端敲命令的方式实现，我们先看下面这一系列操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ pwd</span><br><span class="line">/home/N</span><br><span class="line">[N@Dell ~]$ ls</span><br><span class="line">Data     Documents  intel  Music     Public  Templates</span><br><span class="line">Desktop  Downloads  Model  Pictures  Temp    Videos</span><br><span class="line">[N@Dell ~]$ cd Temp</span><br><span class="line">[N@Dell Temp]$ ls</span><br><span class="line">fhello_world_mpi      hello      sin    solve_equation  test1.c</span><br><span class="line">fhello_world_mpi.f90  hello.f90  sin.c  test1</span><br><span class="line">[N@Dell Temp]$ cp hello hello2</span><br><span class="line">[N@Dell Temp]$ mkdir new</span><br><span class="line">[N@Dell Temp]$ mv hello2 new/</span><br><span class="line">[N@Dell Temp]$ new/hello2 </span><br><span class="line"> Hello world!</span><br><span class="line">[N@Dell Temp]$ rm new/hello2 </span><br><span class="line">rm: remove regular file ‘new/hello2’? y</span><br><span class="line">[N@Dell Temp]$ rmdir new/</span><br><span class="line">[N@Dell Temp]$ cd ..</span><br><span class="line">[N@Dell ~]$</span><br></pre></td></tr></table></figure></p>
<p><code>pwd</code> 是查看当前的目录位置，为 <code>/home/N</code>；<code>ls</code> 为显示当前目录下的内容，可以看到有 <code>Data、Documents......</code>，它们可能是文件夹、各类文件、可执行程序等等；<code>cd</code> 为切换目录，这里进入 <code>Temp</code> 目录，并 <code>ls</code> 显示了 <code>Temp</code> 目录下的内容；<code>cp</code> 为复制文件，把 <code>hello</code> 这个文件复制成 <code>hello2</code>；<code>mkdir</code> 为建立新目录，<code>mv</code> 为移动文件，我把复制得到的 <code>hello2</code> 移动到新建的 <code>new</code> 目录下了；<code>new/hello2</code> 的意思是执行 <code>hello2</code>，这说明 <code>hello2</code> 是个可执行文件，即 Windows 下的 <code>.exe</code> 文件，看，它在屏幕上给你打了个招呼呢！最后我用 <code>rm</code>、和 <code>rmdir</code> 分别删除了 <code>hello2</code> 文件和 <code>new</code> 文件夹，并回到上一级目录（<code>cd ..</code>）。<br>对于上述执行的这些命令，我有几点要说明一下：</p>
<ol>
<li><p>绝对路径和相对路径（可能会有人不太清楚）：绝对路径即完整的路径，如 <code>pwd</code> 后得到的 <code>/home/N</code>；相对路径即相对于当前目录位置的路径，例如当你要进入 <code>/home/N/Temp</code>，但你现在位置为 <code>/home</code> 时，就可以输入 <code>cd N/Temp</code>。顺便提一下几个特殊路径，<code>~</code> 为用户家目录（如对于用户 N，<code>~</code> 相当于 <code>/home/N</code>），<code>.</code>（点）为当前目录，<code>..</code>（两个点）为上一级目录，<code>-</code> 为上一次路径。大家可以用 <code>cd ~</code>，<code>cd .</code>，<code>cd ..</code>，<code>cd -</code> 试试效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ pwd</span><br><span class="line">/home/N</span><br><span class="line">[N@Dell ~]$ cd /home/N/Temp/solve_equation/method1/</span><br><span class="line">[N@Dell method1]$ cd -</span><br><span class="line">/home/N</span><br><span class="line">[N@Dell ~]$ cd ..</span><br><span class="line">[N@Dell home]$</span><br></pre></td></tr></table></figure>
</li>
<li><p>所谓命令，其实也就是程序而已，当你输 <code>ls</code> 的时候，实际上你就是运行了 <code>/usr/bin/ls</code> 这个程序。之前我们也在 <code>/home/N/Temp</code> 下输入 <code>new/hello2</code> 来运行 <code>hello2</code> 这个程序，在我看来，<code>ls</code> 和 <code>hello2</code> 本质上没多大区别，只是一个是系统自带的程序，一个是我写的程序。由于 <code>hello2</code> 被我删了，我们就运行下 <code>hello</code> 吧。以绝对路径的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ /usr/bin/ls</span><br><span class="line">Data	 Documents  intel  Music     Public  Templates</span><br><span class="line">Desktop  Downloads  Model  Pictures  Temp    Videos</span><br><span class="line">[N@Dell ~]$ /home/N/Temp/hello</span><br><span class="line"> Hello world!</span><br></pre></td></tr></table></figure>
<p>不过如果这样输入呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ ls</span><br><span class="line">Data     Documents  intel  Music     Public  Templates</span><br><span class="line">Desktop  Downloads  Model  Pictures  Temp    Videos</span><br><span class="line">[N@Dell ~]$ hello</span><br><span class="line">bash: hello: command not found...</span><br></pre></td></tr></table></figure>
<p>当你输入 <code>ls</code> 时，系统明白你要运行 <code>/usr/bin/ls</code> ，但输入 <code>hello</code> 时系统就晕了，因为你没有事先告诉它你的 <code>hello</code> 在哪。实际上你只需要在某个文件（<code>.bashrc</code>）里写上 <code>hello</code> 的绝对路径，系统就会由那个文件获取 <code>hello</code> 的路径。这样就可以通过直接敲入 <code>hello</code> 来执行而无需敲完整路径了！关于那个文件的事情我们以后再详细聊~<br>你也可以用相对路径的行式来运行 <code>hello</code>，首先 <code>cd /home/N/Temp/</code>，再敲入 <code>./hello</code>，注意这和直接敲 <code>hello</code> 是不同的，之前说过 <code>.</code>（点）是代表当前目录，<code>./hello</code> 相当于给出了相对路径，与 <code>cd /home/N/Temp/</code> 组合起来，系统就知道你的 <code>hello</code> 文件的位置然后正常运行了。<br>这儿有个叫 <code>which</code> 的命令需要提一下，它可以查看某命令的文件路径在哪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ which mv</span><br><span class="line">/usr/bin/mv</span><br></pre></td></tr></table></figure>
<p>若你没有将 <code>hello</code> 的绝对路径写到 <code>.bashrc</code> 文件里，那么 <code>which hello</code> 的结果就是“找不着”哦！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ which hello</span><br><span class="line">/usr/bin/which: no hello in ...（这里省略了若干路径）</span><br></pre></td></tr></table></figure>
</li>
<li><p>不管是所谓的命令，还是你自己写的程序，实际上我们运行它们都是类似这样的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ command [-option] para1 para2 …</span><br></pre></td></tr></table></figure>
<p><code>command</code> 可以是 <code>ls</code> 、<code>/home/N/Temp/hello</code> 等等；<code>-option</code> 为选项，通常以 <code>-</code> 或 <code>--</code>（横杠或双横杠）开头；<code>para1</code>、<code>para2</code> 等即参数。如 <code>ls -l ..</code> 会显示上一级目录的详细（因为有 <code>-l</code> 选项）内容；如 <code>cp -r dir1 dir2</code>，加上 <code>-r</code> 使你可以复制文件夹。实际上，对于每个命令，都有一堆可选择的选项，而又有这么多的命令，怎么可能都记得住嘛！别急，绝大多数命令都有 <code>--help</code> 选项，加上这个选项就可以迅速浏览某命令的各选项简述。若要获得某个命令的详细描述，则可以使用 <code>man</code> 和 <code>info</code> 这两个命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ ls --help</span><br><span class="line">[N@Dell ~]$ man cp</span><br><span class="line">[N@Dell ~]$ info mkdir</span><br></pre></td></tr></table></figure>
<p>我觉得吧，了解了之前的那些简单操作后，大家应该先学好 <code>man</code> 命令，这样以后遇到新命令，就直接 <code>man</code> 一下，就什么都知道了哦！另外，你可以先 <code>man</code> 一下 <code>man</code> ，里面会有对 <code>man</code> 的详细说明的，然后百度一下就会了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ man man</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时候我们需要反复执行同一条命令，当这条命令超级长的时候，我想你肯定不耐烦一遍遍输入吧，因此我们要了解下如何查看历史操作。一般在命令行直接用 <code>↑</code>, <code>↓</code> 方向键就行了，不过这里再介绍下其他方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ history</span><br><span class="line">[N@Dell ~]$ !1000</span><br></pre></td></tr></table></figure>
<p><code>history</code> 会列出你之前执行的命令，<code>!1000</code> 则执行 <code>history</code> 中编号为1000的那条命令。另外，在命令行按下组合键 <code>Ctrl+r</code> 后再输入你的命令，也能快速搜索历史操作并执行。<br>还有自动补全功能，<code>tab</code> 与 <code>tabtab</code>（按两次），也能让你少敲不少字符。（ps：有些系统并不是用 <code>tab</code> 来进行补全哟~）<br>对了，如果执行某个命令时半天没有回应，你可以试试按下组合键 <code>Ctrl+C</code> 来终止命令。比如你用 <code>du</code> 时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N@Dell ~]$ du –sh /</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="其他常用的命令"><a href="#其他常用的命令" class="headerlink" title="其他常用的命令"></a>其他常用的命令</h1><p>用户权限：<code>chown</code>、<code>chgrp</code>、<code>chmod</code>、<code>passwd</code>、<code>su</code><br>压缩、解压及打包：<code>gzip</code>、<code>bzip2</code>、<code>tar</code><br>查看文件内容：<code>cat</code>、<code>more</code>、<code>less</code>、<code>head</code>、<code>tail</code><br>搜索：<code>which</code>、<code>find</code>、<code>grep</code>、<code>locate</code><br>网络：<code>ping</code>、<code>ifconfig</code>…<br>系统资源信息：<code>df</code>、<code>du</code>、<code>top</code>、<code>free</code>…<br>文件：<code>ln</code>、<code>touch</code>、<code>diff</code>、<code>stat</code><br>日期：<code>date</code>、<code>cal</code><br>……<br>我简单列了一些命令供大家查询练习，但 Linux 的神奇与强大，需要大家自己去摸索研究~<br>还有大家平时就用普通用户帐号（如我的 N 帐号）吧，管理系统时才需要使用 root 帐号。</p>
<h1 id="心得（不如说是感慨吧）"><a href="#心得（不如说是感慨吧）" class="headerlink" title="心得（不如说是感慨吧）"></a>心得（不如说是感慨吧）</h1><ol>
<li>作为非计算机专业的我们，其实并不需要“按部就班”地学习 Linux，或者说不需要抱着本书从头看到尾，而是在了解基本知识后就可以边学习边使用它做些工作了。这样不用浪费太多时间，最重要的是使用它会让你更快地熟悉了解它。</li>
<li>由于我们是“跳着”学的，肯定会经常遇到不懂的问题需要上网搜索，这时对信息的检索能力就十分重要了，才可以迅速找到解决方法啊！相互交流，多多讨教也是一种有效的方式！</li>
<li>从计算机的角度出发进行思考。我时常会琢磨，Linux 作为一类优秀的系统，有哪些能力是理所当然会具备的呢？或者对于 Windows 下许多功能，它又将如何实现呢？比如 Linux 应该能对各用户合理分配资源吧，那需要做些什么呢？再想想 Linux 下怎么查看一个文件夹含有的所有文件数呢？就这样自己思考问题，然后去搜索答案，那么许多问题在出现之前就已经被解决了，相比临时遇到问题再搜索的方式，要节省时间得多。此外，这样也让你思维更活跃，说不定遇到问题时自己突然就知道如何解决了，嗯。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>因为我想让第一次使用 Linux 的人能够快速熟悉，许多操作说明难免有些繁琐、啰嗦，之后肯定会以更加简明的形式描述的。最后，如果有问题的话，可以去气象家园给我留言哈！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 入门教程——Linux 简介]]></title>
      <url>http://nearsc.github.io/2017/08/19/06climate-linux-intro-1/</url>
      <content type="html"><![CDATA[<p>气象家园投稿第一篇：Linux 简介</p>
<a id="more"></a>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Hi，大家好！我是受“风往北吹”前辈的邀请，想写写关于 Linux 入门教程的一个无名小卒，面对的受众大概是那些刚开始研究生生活，对 Linux 系统了解不多的童鞋吧（微笑<br>我本人真正开始使用 Linux 的时间也不算长，水平有限，可能分享的内容远不及大神们的有用。希望能和大家多多交流，相互学习。另外，对于可能出现的错误，还请大家多多指正。</p>
<h1 id="我眼里的-Linux"><a href="#我眼里的-Linux" class="headerlink" title="我眼里的 Linux"></a>我眼里的 Linux</h1><p>随便翻开一本 Linux 教程，开头都要讲讲 Linux 的历史。我感觉关于历史的信息，大家大可自己去书上读一读，所以我想了想还是跳过这部分，直接聊一聊自己对 Linux 的整体认识或者我是怎么看待 Linux 的。<br>大多数人最开始接触的应该都是 Windows 系统，现在突然要改用另一种系统，我们就要先了解这个新系统和我们平时用的究竟有多大不同。在我看来，两个系统其实都是在做着相同的事，即为我们提供一个使用计算机各个硬件的外部接口，通过操作系统提供的接口，我们可以使用鼠标键盘进行输入，调用 CPU 进行计算，用显示器查看结果。而对于它俩的区别，我觉得 Windows 看起来像是一位神奇的魔术师，而 Linux 则像是精明的科学家；或者 Windows 像是偏于感性的右脑，而 Linux 则为理性的左脑。这么形容它们，主要是因为 Windows 善于给我们呈现视听上的多彩，而 Linux 则注重内核的优化（更有效地使用计算机）吧。<br>要是稍微具体地说说 Linux 与 Windows 的差异，最直观最先感觉到的，就是会话界面和图形界面的区别了（当然不少 Linux 发行版也带有图形界面）。Windows 下对系统的简单操作主要是由鼠标来完成（码字的时候还是靠键盘咯），因为它有很不错的图形界面，让操作变得形象化；而一开始使用 Linux 时，总感觉自己在用上世纪的电脑，要不厌其烦的通过输入字符来告诉它你的想法。相信有些不太喜欢编程的筒子们有些上手困难，不过呢，习惯就好啦！甚至还会变得爱上这种敲命令的操作方式了呢！<br>我要提到的另一个事，是关于多用户的问题，但这并不是两个系统间的差异，而是使用服务器时需要关注的问题。尽管 Windows 也是多用户的系统，但它一般都是安装在个人电脑上，基本也就是个人使用，用户除了你自己以外，就只有几个特殊的用户了吧（Administrator、Guest、System）。当然 Windows 也有服务器版本，但在服务器上 Linux 使用更为广泛，这意味着，如果你在服务器上使用 Linux 时，将会有一堆人跟你抢用计算资源，也意味着你需要知道在 Linux 下如何查看计算机的使用情况。这就好比是你在 Windows 下突然发现电脑特别卡了，就会调出任务管理器，看看是不是有些进程占了很多资源，然后干掉它！不同的是，在服务器上你并不能轻易的就把人家的进程给 K.O. 了（无奈<br>慢着，还有一件事我觉得有必要说一下！是关于编写程序或者使用数值模式时的问题。在 Windows 下面，我们写好源代码以后，点击编译器的编译、链接、运行……结果就出来了；或者有些可以在 Windows 下安装的数值模式，使用时可能只需要按照向导点一点，结果也就出来了。但在 Linux 下面，不光编译、链接、运行这三个步骤需要你通过打字敲命令来实现，而且还有一堆关于环境的设置问题需要你自己解决。简单来说就是，在 Windows 下的点击，其实伴随着编译器的一系列繁杂的动作，而在 Linux 下这些动作都需要你自己来完成！我那不长的模式调试经历，就已经让我明白，有时候这就是个麻烦事儿。T_T</p>
<h1 id="傻瓜式的-Linux-安装教程"><a href="#傻瓜式的-Linux-安装教程" class="headerlink" title="傻瓜式的 Linux 安装教程"></a>傻瓜式的 Linux 安装教程</h1><p>由于 Linux 系统的开源性，其发行版可以说是种类繁多，大致列举几个吧：RedHat、Ubuntu、Fedora、Debian、CentOS、Deepin（国产）等等。Linux 的桌面环境（给你的 Linux 装一个图形界面，如 GNOME、KDE 等，用起来也有了 Windows 的一些便捷之处）也在不断改善，对文字处理、图片、视频音频播放等方面的支持也不错，总有预感 Linux 的普及度将越来越广，说不定以后在个人电脑市场上也要给 Windows 施压呢！<br><img src="/2017/08/19/06climate-linux-intro-1/pic_1.png" alt="pic_1.png" title=""><br>下面我就稍微示范下在个人电脑上傻瓜式安装 Fedora 23 的步骤吧！<br>需要的工具：LiveUSB Creator 软件、Fedora 23 镜像文件、8G 以上U盘、一台电脑</p>
<ol>
<li>制作安装 Fedora 23 的启动U盘：<br>下载 <a href="https://fedorahosted.org/liveusb-creator/" target="_blank" rel="external">LiveUSB Creator</a>，以及 <a href="https://getfedora.org/zh_CN/workstation/download/" target="_blank" rel="external">Fedora 23的光盘镜像</a>，打开 LiveUSB Creator。<br>LiveUSB Creator 是 Fedora 官网上的一个小工具，用来制作启动U盘，操作非常简单，一目了然，相信大家看了就会用~<img src="/2017/08/19/06climate-linux-intro-1/pic_2.png" alt="pic_2.png" title="">
<img src="/2017/08/19/06climate-linux-intro-1/pic_3.png" alt="pic_3.png" title="">
我们已经下好了 Fedora 23 的镜像文件，那么就选左边的方式吧（Use existing Live CD）！选好镜像文件及要刻的那个U盘，就可以开始制作启动U盘了。<br>做好启动U盘以后就重启电脑，然后进行安装吧！</li>
<li>用U盘启动 Fedora 23 安装程序，进行安装：<br>重启电脑后要选择从U盘启动，即刚才你制作的那个U盘<img src="/2017/08/19/06climate-linux-intro-1/pic_4.jpg" alt="pic_4.jpg" title="">
<img src="/2017/08/19/06climate-linux-intro-1/pic_5.jpg" alt="pic_5.jpg" title="">
然后就可以看到U盘里的东西嘞！你可以选择先体验一下，或者现在就开始安装！<img src="/2017/08/19/06climate-linux-intro-1/pic_6.jpg" alt="pic_6.jpg" title="">
<img src="/2017/08/19/06climate-linux-intro-1/pic_7.jpg" alt="pic_7.jpg" title="">
安装过程按照提示就可以了，不过要注意选好你要安装 Fedora 的那个硬盘哦~（叹号那个）<br>因为我已经在自己电脑上装过 Fedora 啦，所以我就尝试着给另一个U盘装了个 Fedora（偷笑<img src="/2017/08/19/06climate-linux-intro-1/pic_8.jpg" alt="pic_8.jpg" title="">
<img src="/2017/08/19/06climate-linux-intro-1/pic_9.jpg" alt="pic_9.jpg" title="">
开始安装！这时你可以设置 root 帐号的密码，以及创建一个新用户。<br>耐心等待后，一个属于你自己的 Linux 系统就诞生啦！（由于我是在U盘上装的，它不太给力，安装过程等的我好苦啊）<img src="/2017/08/19/06climate-linux-intro-1/pic_10.jpg" alt="pic_10.jpg" title="">
<img src="/2017/08/19/06climate-linux-intro-1/pic_11.jpg" alt="pic_11.jpg" title="">
PS：“制作启动U盘”和“把 Fedora 装在U盘上”，这是不同的过程哦~所以我用到了两个U盘，正常情况下是一个启动U盘+一块硬盘（为了避免误解，还是画蛇添足地说明下吧）</li>
</ol>
<p>好了，第一期就到这了，希望可以帮助到大家吧！也希望这是一个不错的开头~~~^。^</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 命令备忘录]]></title>
      <url>http://nearsc.github.io/2017/08/19/linux-notes/</url>
      <content type="html"><![CDATA[<p>记录一些比较实用的linux命令。当然，每个命令的描述会尽可能地被缩短，以保持页面的简洁感。如果以后想要单独写几篇笔记，对某些命令进行详细的研究，那这个页面也可以作为一个很好的索引页。</p>
<a id="more"></a>
<h1 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h1><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><pre><code>wget -nH --cut-dirs=* -m --ftp-user=* --ftp-password=* ftp://*.*.*.*/*
</code></pre><p>-nH：不创建以主机名命名的目录<br>–cut-dirs：忽略主机上的目录层数<br>-m：下载所有子目录并且保留目录结构<br>–ftp-user：FTP用户名<br>–ftp-password：FTP密码<br>ftp://<em>.</em>.<em>.</em>/*：FTP主机地址。最后可以跟目录名来下载指定目录</p>
<h1 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h1><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><pre><code>date -u -d * -s * +%y%m%d%H
</code></pre><p>-u：获取UTC时间<br>-d：不指定时获取当前时间，指定时获取特定时间<br>-s：设置系统时间<br>+*：指定时间格式</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sudoku 测试页]]></title>
      <url>http://nearsc.github.io/2017/06/16/sudoku/</url>
      <content type="html"><![CDATA[<p>就当是熟悉下JS啦，当然完成度还不高，大概50%吧？</p>
<a id="more"></a>
<p><form action="" id="form1"></form></p>
<script type="text/javascript" src="/js/sudoku.js"></script>
<script type="text/javascript">
    sudoku = new Sudoku();
    sudoku.initSudoku("form1", sudoku);
</script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vi 备忘录（未完待续）]]></title>
      <url>http://nearsc.github.io/2016/06/26/vi-notes/</url>
      <content type="html"><![CDATA[<p>虽说已经用了很久的vi，可是对于vi不同功能的熟练程度是不同的，这意味着有时会忘掉某些操作而需要查阅相关信息。此时若是手边没有参考书，就非常令人抓狂，只好去网上进行搜索。既然如此，那就花点时间整理下吧，查阅起来应该方便不少。我个人习惯是把vi和vim混在一起统称为vi的，因此尽管标题是“Vi 备忘录”，但其实也包含了vim的功能。</p>
<a id="more"></a>
<h1 id="Vi-的简介"><a href="#Vi-的简介" class="headerlink" title="Vi 的简介"></a>Vi 的简介</h1><h2 id="Vi-的基本模式"><a href="#Vi-的基本模式" class="headerlink" title="Vi 的基本模式"></a>Vi 的基本模式</h2><p>使用 <code>vi</code> 时主要有四种模式：<code>一般模式</code>、<code>插入模式</code>、<code>命令行模式</code>、<code>可视化模式</code>。<code>一般模式</code> 下可以快速浏览文本，<code>插入模式</code> 下可以自由编辑文本，<code>命令行模式</code> 下可以进行搜索、保存等特殊操作，<code>可视化模式</code> 下可以进行块操作。</p>
<h2 id="Vi-的特性"><a href="#Vi-的特性" class="headerlink" title="Vi 的特性"></a>Vi 的特性</h2><p>未完待续</p>
<h1 id="Vi-命令快速查询"><a href="#Vi-命令快速查询" class="headerlink" title="Vi 命令快速查询"></a>Vi 命令快速查询</h1><p>这里根据各命令的功能进行归类总结。值得注意的是，许多命令都可以在前面加上数字n，来完成n次操作；也可以进行 <code>操作+移动</code> 的组合，来进行快速操作，如 <code>d$</code> 。</p>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>(n)h 或 (n)← 或 (n)[Backspace] 或 (n)[Ctrl]h</td>
<td>向左移动一(n)个字符</td>
</tr>
<tr>
<td>(n)j 或 (n)↓ 或 (n)[Ctrl]n 或 (n)[Ctrl]j</td>
<td>向下移动一(n)行</td>
</tr>
<tr>
<td>(n)k 或 (n)↑ 或 (n)[Ctrl]p</td>
<td>向上移动一(n)行</td>
</tr>
<tr>
<td>(n)l 或 (n)→ 或 (n)[space]</td>
<td>向右移动一(n)个字符</td>
</tr>
<tr>
<td>(n)[Ctrl]f 或 (n)[Page Down]</td>
<td>向下移动一(n)页</td>
</tr>
<tr>
<td>(n)[Ctrl]b 或 (n)[Page Up]</td>
<td>向上移动一(n)页</td>
</tr>
<tr>
<td>(n)[Ctrl]d</td>
<td>向下移动半页(n行)</td>
</tr>
<tr>
<td>(n)[Ctrl]u</td>
<td>向上移动半页(n行)</td>
</tr>
<tr>
<td>(n)[Ctrl]e</td>
<td>向下滚动一(n)行</td>
</tr>
<tr>
<td>(n)[Ctrl]y</td>
<td>向上滚动一(n)行</td>
</tr>
<tr>
<td>0 或 [Home]</td>
<td>移动至当前行行首</td>
</tr>
<tr>
<td>(n)$ 或 (n)[End]</td>
<td>移动至当前行(向下第n行)行尾</td>
</tr>
<tr>
<td>^ 或 _</td>
<td>移动至当前行的非空格行首</td>
</tr>
<tr>
<td>(n)+ 或 (n)[Enter] 或 (n)[Ctrl]m</td>
<td>移动至下一(n)行的非空格行首</td>
</tr>
<tr>
<td>(n)-</td>
<td>移动至上一(n)行的非空格行首</td>
</tr>
<tr>
<td>(n)zt 或 (n)z[Enter]</td>
<td>将当前（第n）行滚动至屏幕顶部</td>
</tr>
<tr>
<td>(n)zz 或 (n)z.</td>
<td>将当前（第n）行滚动至屏幕中间</td>
</tr>
<tr>
<td>(n)zb 或 (n)z-</td>
<td>将当前（第n）行滚动至屏幕底部</td>
</tr>
<tr>
<td>[Ctrl]o</td>
<td>移动至较早的位置</td>
</tr>
<tr>
<td>(n)|</td>
<td>移动至当前行第一(n)列</td>
</tr>
<tr>
<td>(</td>
<td>移动至上一个句子的开头</td>
</tr>
<tr>
<td>)</td>
<td>移动至下一个句子的开头</td>
</tr>
<tr>
<td>{</td>
<td>移动至上一个段落</td>
</tr>
<tr>
<td>}</td>
<td>移动至下一个段落</td>
</tr>
<tr>
<td>[[</td>
<td></td>
</tr>
<tr>
<td>]]</td>
<td></td>
</tr>
<tr>
<td>(n)H</td>
<td>移动至屏幕第一(n)行的非空格行首</td>
</tr>
<tr>
<td>M</td>
<td>移动至屏幕中间行的非空格行首</td>
</tr>
<tr>
<td>(n)L</td>
<td>移动至屏幕倒数第一(n)行的非空格行首</td>
</tr>
<tr>
<td>(n)w</td>
<td>移动至下一(n)个单词词首</td>
</tr>
<tr>
<td>(n)e</td>
<td>移动至下一(n)个单词词尾</td>
</tr>
<tr>
<td>(n)b</td>
<td>移动至上一(n)个单词词首</td>
</tr>
<tr>
<td>(n)ge</td>
<td>移动至上一(n)个单词词尾</td>
</tr>
<tr>
<td>(n)W</td>
<td>移动至下一(n)个单词词首，跳过标点符号</td>
</tr>
<tr>
<td>(n)E</td>
<td>移动至下一(n)个单词词尾，跳过标点符号</td>
</tr>
<tr>
<td>(n)B</td>
<td>移动至上一(n)个单词词首，跳过标点符号</td>
</tr>
<tr>
<td>(n)gE</td>
<td>移动至上一(n)个单词词尾，跳过标点符号</td>
</tr>
<tr>
<td>G</td>
<td>移动至最后一行</td>
</tr>
<tr>
<td>nG</td>
<td>移动至第n行</td>
</tr>
<tr>
<td>gg</td>
<td>移动至第一行</td>
</tr>
<tr>
<td>f[char]</td>
<td>移动至当前行下一个字符char</td>
</tr>
<tr>
<td>F[char]</td>
<td>移动至当前行上一个字符char</td>
</tr>
<tr>
<td>t[char]</td>
<td>移动至当前行下一个字符char的前一个字符</td>
</tr>
<tr>
<td>T[char]</td>
<td>移动至当前行上一个字符char的后一个字符</td>
</tr>
<tr>
<td>;</td>
<td>执行上一次的[fFtT]</td>
</tr>
<tr>
<td>,</td>
<td>;的反向，;为[fFtT]则,为[FfTt]</td>
</tr>
<tr>
<td>%</td>
<td>移动至与当前括号匹配的括号，包括()、[]、{}、&lt;&gt;等</td>
</tr>
<tr>
<td>n%</td>
<td>移动至文件n%处</td>
</tr>
</tbody>
</table>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>使用 <code>d</code> 进行删除时，可以通过 <code>(n1)d(n2)[CursorMove]</code> 的形式将 <code>d</code> 与光标移动 <code>[CursorMove]</code> 进行组合，对当前位置至目标位置间的字符进行删除，并且利用n1、n2来进行多次操作。<br>列举部分有关 <code>d</code> 的操作，未列举的可参考 <code>光标移动</code> 部分的内容。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>(n)dd 或 d(n)d</td>
<td>向下删除一(n)行（从当前行开始计算）</td>
</tr>
<tr>
<td>dG</td>
<td>删除当前行至最后一行</td>
</tr>
<tr>
<td>dnG</td>
<td>删除当前行至第n行</td>
</tr>
<tr>
<td>dgg</td>
<td>删除当前行至第1行</td>
</tr>
<tr>
<td>d0</td>
<td>删除当前光标至行首</td>
</tr>
<tr>
<td>d$ 或 D</td>
<td>删除当前光标至行尾</td>
</tr>
<tr>
<td>(n)dw 或 d(n)w</td>
<td>从当前光标开始向后删除至下一(n)个单词词首前</td>
</tr>
<tr>
<td>(n)de 或 d(n)e</td>
<td>从当前光标开始向后删除至下一(n)个单词词尾后</td>
</tr>
<tr>
<td>(n)db 或 d(n)b</td>
<td>从当前光标开始向前删除至上一(n)个单词词首前</td>
</tr>
<tr>
<td>(n)dge 或 d(n)ge</td>
<td>从当前字符后开始向前删除至上一(n)个单词词尾前</td>
</tr>
<tr>
<td>(n1)d(n2)[w/e/b/ge]</td>
<td>同上，但处理n1×n2个单词</td>
</tr>
<tr>
<td>daw</td>
<td>从单词开头开始向后删除至下一个单词词首前(不确定)</td>
</tr>
<tr>
<td>diw</td>
<td></td>
</tr>
<tr>
<td>das</td>
<td></td>
</tr>
<tr>
<td>dis</td>
<td></td>
</tr>
<tr>
<td>df[char]</td>
<td></td>
</tr>
<tr>
<td>dF[char]</td>
<td></td>
</tr>
<tr>
<td>dt[char]</td>
<td></td>
</tr>
<tr>
<td>dT[char]</td>
<td></td>
</tr>
<tr>
<td>(n)d/string 或 d(n)/string</td>
<td>向下搜索字符串string，并从当前光标开始向后删除至下一个string前</td>
</tr>
<tr>
<td>(n)d?string 或 d(n)?string</td>
<td>向上搜索字符串string，并从当前光标开始向前删除至下一个string前</td>
</tr>
<tr>
<td>[Del]</td>
<td>向后删除一个字符</td>
</tr>
<tr>
<td>(n)x</td>
<td>向后删除一(n)个字符</td>
</tr>
<tr>
<td>(n)X</td>
<td>向前删除一(n)个字符</td>
</tr>
</tbody>
</table>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>使用 <code>y</code> 进行删除时，可以通过 <code>(n1)y(n2)[CursorMove]</code> 的形式将 <code>y</code> 与光标移动 <code>[CursorMove]</code> 进行组合，对当前位置至目标位置间的字符进行删除，并且利用n1、n2来进行多次操作。<br>列举部分有关 <code>y</code> 的操作，未列举的可参考 <code>光标移动</code> 部分和 <code>删除</code> 部分的内容。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>(n)yy 或 (n)Y</td>
<td>向下复制一(n)行（从当前行开始计算）</td>
</tr>
<tr>
<td>yG</td>
<td>复制当前行至最后一行</td>
</tr>
<tr>
<td>ynG</td>
<td>复制当前行至第n行</td>
</tr>
<tr>
<td>ygg</td>
<td>复制当前行至第1行</td>
</tr>
<tr>
<td>y0</td>
<td>复制当前光标至行首</td>
</tr>
<tr>
<td>y$</td>
<td>复制当前光标至行尾</td>
</tr>
<tr>
<td>Y</td>
<td>相当于yy</td>
</tr>
<tr>
<td>yw</td>
<td></td>
</tr>
<tr>
<td>yb</td>
<td></td>
</tr>
<tr>
<td>ye</td>
<td></td>
</tr>
<tr>
<td>yaw</td>
<td></td>
</tr>
<tr>
<td>y/string</td>
<td></td>
</tr>
<tr>
<td>y?string</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>(n)J</td>
<td>删除换行符，连接下一(n)行与当前行</td>
</tr>
<tr>
<td>(n)p</td>
<td>将已复制或删除的内容粘贴一(n)份至下一行或当前字符后</td>
</tr>
<tr>
<td>(n)P</td>
<td>将已复制或删除的内容粘贴一(n)份至上一行或当前字符前</td>
</tr>
<tr>
<td>(n)u</td>
<td>撤销一(n)次操作</td>
</tr>
<tr>
<td>U</td>
<td>恢复上一次修改行的所有修改</td>
</tr>
<tr>
<td>(n)[Ctrl]r</td>
<td>恢复一(n)次撤销</td>
</tr>
<tr>
<td>.</td>
<td>重复上一个操作</td>
</tr>
<tr>
<td>(n)&gt;&gt; 或 &gt;(n)&gt;</td>
<td>将当前行（向下n行）向右移动shiftwidth的距离</td>
</tr>
<tr>
<td>(n)&lt;&lt; 或 &lt;(n)&lt;</td>
<td>将当前行（向下n行）向左移动shiftwidth的距离</td>
</tr>
<tr>
<td>(n)~</td>
<td>更改一(n)个字母的大小写，并向后移动一(n)个字符</td>
</tr>
<tr>
<td>(n)[Ctrl]a</td>
<td>使当前数字加一(n)</td>
</tr>
</tbody>
</table>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>(n)i</td>
<td>从当前光标插入（重复n次）</td>
</tr>
<tr>
<td>(n)I</td>
<td>从行首插入（重复n次）</td>
</tr>
<tr>
<td>(n)a</td>
<td>从当前光标下一个字符后插入（重复n次）</td>
</tr>
<tr>
<td>(n)A</td>
<td>从行尾插入（重复n次）</td>
</tr>
<tr>
<td>(n)o</td>
<td>从下一行插入新行（重复n次）</td>
</tr>
<tr>
<td>(n)O</td>
<td>从上一行插入新行（重复n次）</td>
</tr>
<tr>
<td>(n)r</td>
<td>单次替换一(n)个字符</td>
</tr>
<tr>
<td>R</td>
<td>多次替换字符</td>
</tr>
<tr>
<td>(n)cc 或 c(n)c 或 (n)S</td>
<td>向下删除一(n)行，并从新行插入（从当前行开始计算）</td>
</tr>
<tr>
<td>(n)cw 或 c(n)w</td>
<td>从当前光标开始向后删除至下一个单词词尾，并从当前光标插入</td>
</tr>
<tr>
<td>(n)ce 或 c(n)e</td>
<td>同上</td>
</tr>
<tr>
<td>(n)cb 或 c(n)b</td>
<td></td>
</tr>
<tr>
<td>caw</td>
<td>从单词开头开始向后删除至下一个单词词首，并从当前光标插入(不确定)</td>
</tr>
<tr>
<td>c0</td>
<td>删除当前光标至行首，并从当前光标插入</td>
</tr>
<tr>
<td>c$ 或 C</td>
<td>删除当前光标至行尾，并从当前光标插入</td>
</tr>
<tr>
<td>c/string</td>
<td></td>
</tr>
<tr>
<td>c?string</td>
<td></td>
</tr>
<tr>
<td>(n)s</td>
<td>删除一(n)个字符，并从当前光标插入</td>
</tr>
</tbody>
</table>
<h2 id="块选取"><a href="#块选取" class="headerlink" title="块选取"></a>块选取</h2><p>进入块选取后可以使用移动光标的快捷键来快速选取</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>v</td>
<td>按字符进行块选取</td>
</tr>
<tr>
<td>V</td>
<td>按行进行块选取</td>
</tr>
<tr>
<td>[Ctrl]v</td>
<td>按矩形进行块选取</td>
</tr>
<tr>
<td>y</td>
<td>块选取后复制反白区域</td>
</tr>
<tr>
<td>d</td>
<td>块选取后删除反白区域</td>
</tr>
<tr>
<td>c</td>
<td>按矩形进行块选取后，替换反白区域</td>
</tr>
<tr>
<td>~</td>
<td>更改泛白区域的字母大小写</td>
</tr>
</tbody>
</table>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>可以对特定位置进行标记，以达到快速访问与跳转的目的。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>m[mark]</td>
<td>将当前行设置标记[mark]，[mark]取为[a-z]</td>
</tr>
<tr>
<td>y’[mark]</td>
<td>复制标记为[mark]的行至当前行之间的内容</td>
</tr>
<tr>
<td>d’[mark]</td>
<td>删除标记为[mark]的行至当前行之间的内容</td>
</tr>
<tr>
<td>‘[mark]</td>
<td>移动至标记[mark]所在行的非空格行首</td>
</tr>
<tr>
<td>‘’ 或 ‘`</td>
<td>移动至上一行的非空格行首</td>
</tr>
<tr>
<td>`[mark]</td>
<td>移动至标记[mark]所在行的具体位置</td>
</tr>
<tr>
<td>`` 或 `‘</td>
<td>移动至上一行的具体位置</td>
</tr>
<tr>
<td>‘.</td>
<td></td>
</tr>
<tr>
<td>`.</td>
<td></td>
</tr>
<tr>
<td>:marks</td>
<td>查看所有标记</td>
</tr>
</tbody>
</table>
<h2 id="宏与寄存器"><a href="#宏与寄存器" class="headerlink" title="宏与寄存器"></a>宏与寄存器</h2><p>将一系列操作以宏的形式保存至寄存器中，以达到快速执行重复操作的目的。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>q[register]和q</td>
<td>将一系列操作设置为宏存至寄存器[register]，[register]取为[a-z]</td>
</tr>
<tr>
<td>“[register]yy</td>
<td>复制当前行至[register]中</td>
</tr>
<tr>
<td>“[register]dd</td>
<td>删除当前行至[register]中</td>
</tr>
<tr>
<td>“[register]p</td>
<td>复制[register]内容至下一行</td>
</tr>
<tr>
<td>(n)@[register]</td>
<td>执行一(n)次寄存器[register]内的宏</td>
</tr>
<tr>
<td>@@</td>
<td>执行上一次执行的宏（只执行一次，不论上一次执行了多少次）</td>
</tr>
</tbody>
</table>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>未完待续</p>
<h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Ctrl]n</td>
<td>输入提示与自动补全（向下）</td>
</tr>
<tr>
<td>[Ctrl]p</td>
<td>输入提示与自动补全（向上）</td>
</tr>
<tr>
<td>[Ctrl]e</td>
<td>逐个字符复制下一行</td>
</tr>
<tr>
<td>[Ctrl]y</td>
<td>逐个字符复制上一行</td>
</tr>
<tr>
<td>[Ctrl]o</td>
<td>临时切换至一般模式</td>
</tr>
<tr>
<td>[Esc] 或 [Ctrl][</td>
<td>插入模式切换至一般模式</td>
</tr>
<tr>
<td>[Backspace] 或 [Ctrl]h</td>
<td>插入模式中向左删除一个字符</td>
</tr>
</tbody>
</table>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存文件</td>
</tr>
<tr>
<td>:w &gt;&gt; [file]</td>
<td>以追加的形式保存文件至[file]</td>
</tr>
<tr>
<td>:w!</td>
<td>强制保存文件</td>
</tr>
<tr>
<td>:q</td>
<td>退出文件（要求修改已保存）</td>
</tr>
<tr>
<td>:q!</td>
<td>退出但不保存</td>
</tr>
<tr>
<td>:wq</td>
<td>保存后退出</td>
</tr>
<tr>
<td>:w [file]</td>
<td>另存为[file]</td>
</tr>
<tr>
<td>ZZ</td>
<td>若文件无改动则不保存退出，若文件被改动则保存后退出</td>
</tr>
<tr>
<td>:r [file]</td>
<td>在下一行插入[file]的内容</td>
</tr>
<tr>
<td>:n r [file]</td>
<td>在第n行的下一行插入[file]的内容</td>
</tr>
<tr>
<td>:e!</td>
<td>返回至上次保存后的状态，相当于重新打开</td>
</tr>
</tbody>
</table>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>(n)/string</td>
<td>向下搜索字符串string的第一(n)个匹配项</td>
</tr>
<tr>
<td>(n)?string</td>
<td>向上搜索字符串string的第一(n)个匹配项</td>
</tr>
<tr>
<td>/string\c</td>
<td></td>
</tr>
<tr>
<td>/\<string\></string\></td>
<td></td>
</tr>
<tr>
<td>n</td>
<td>移动至下一个搜索的匹配项</td>
</tr>
<tr>
<td>N</td>
<td>移动至上一个搜索的匹配项</td>
</tr>
<tr>
<td>gd</td>
<td>搜索当前单词，并停留在当前匹配项</td>
</tr>
<tr>
<td>(n)#</td>
<td>搜索当前单词，并移动到上一(n)个匹配项</td>
</tr>
<tr>
<td>(n)*</td>
<td>搜索当前单词，并移动到下一(n)个匹配项</td>
</tr>
</tbody>
</table>
<h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:% [action]</td>
<td>对所有行进行操作[action]</td>
</tr>
<tr>
<td>:n1,n2 [action]</td>
<td>对第n1行至n2行之间执行操作[action]，’1,$’同’%’</td>
</tr>
<tr>
<td>:n [action]</td>
<td>对第n行执行操作[action]</td>
</tr>
<tr>
<td>:n1,n2 y</td>
<td>复制第n1至n2行之间内容</td>
</tr>
<tr>
<td>:n1,n2 d</td>
<td>删除第n1至n2行之间内容</td>
</tr>
<tr>
<td>:n1,n2 m n3</td>
<td>将第n1至n2行移动到第n3行之后</td>
</tr>
<tr>
<td>:n1,n2 co n3</td>
<td>将第n1至n2行复制到第n3行之后</td>
</tr>
<tr>
<td>:n1,n2 w [file]</td>
<td>将第n1至n2行另存为[file]</td>
</tr>
<tr>
<td>:n1,n2 w ![command]</td>
<td>将第n1至n2行作为标准输入来执行[command]</td>
</tr>
<tr>
<td>:n1,n2 s/str1/str2/</td>
<td>在第n1至n2行之间搜索第一个str1并替换成str2</td>
</tr>
<tr>
<td>:n1,n2 s/str1/str2/g</td>
<td>在第n1至n2行之间搜索str1并替换成str2</td>
</tr>
<tr>
<td>:n1,n2 s/str1/str2/gc</td>
<td>在第n1至n2行之间搜索str1并替换成str2，替换前需确认</td>
</tr>
<tr>
<td>:n1,n2 &gt;&gt;</td>
<td>将第n1行至n2行之间向右移动一个[tab]</td>
</tr>
<tr>
<td>:n1,n2 &lt;&lt;</td>
<td>将第n1行至n2行之间向左移动一个[tab]</td>
</tr>
<tr>
<td>:g/str/d</td>
<td></td>
</tr>
<tr>
<td>:s 或 :&amp;</td>
<td>执行上一步的s/str1/str2/g命令</td>
</tr>
<tr>
<td>:@:</td>
<td>执行上一次的命令行模式的命令</td>
</tr>
</tbody>
</table>
<h2 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:![command]</td>
<td>暂时离开vi并执行命令[command]</td>
</tr>
<tr>
<td>:!!</td>
<td>执行上一次的外部命令</td>
</tr>
<tr>
<td>:.![command]</td>
<td></td>
</tr>
<tr>
<td>:sh</td>
<td>暂时离开vi执行多条命令</td>
</tr>
<tr>
<td>[Ctrl]d</td>
<td>执行:sh后由此操作回到vi</td>
</tr>
<tr>
<td>:r ![command]</td>
<td>执行外部命令并将其标准输出插入至下一行</td>
</tr>
</tbody>
</table>
<h2 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:vi[file]</td>
<td>在vi中打开另一个文件[file]</td>
</tr>
<tr>
<td>:n</td>
<td>切换至下一个文件</td>
</tr>
<tr>
<td>:N</td>
<td>切换至上一个文件</td>
</tr>
<tr>
<td>:next</td>
<td></td>
</tr>
<tr>
<td>:previous</td>
<td></td>
</tr>
<tr>
<td>:wnext</td>
<td></td>
</tr>
<tr>
<td>:args</td>
<td></td>
</tr>
<tr>
<td>:args [file1] [file2] …</td>
<td></td>
</tr>
<tr>
<td>:last</td>
<td></td>
</tr>
<tr>
<td>:first</td>
<td></td>
</tr>
<tr>
<td>[Ctrl]^</td>
<td>返回至上一个编辑的文件</td>
</tr>
<tr>
<td>:file</td>
<td>列出当前文件的信息</td>
</tr>
<tr>
<td>:files</td>
<td>列出所有打开的文件</td>
</tr>
</tbody>
</table>
<h2 id="多窗口编辑"><a href="#多窗口编辑" class="headerlink" title="多窗口编辑"></a>多窗口编辑</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:split</td>
<td>打开新窗口显示当前文件（水平排列）</td>
</tr>
<tr>
<td>:split [file]</td>
<td>打开新窗口显示file（水平排列）</td>
</tr>
<tr>
<td>:vsplit</td>
<td>打开新窗口显示当前文件（垂直排列）</td>
</tr>
<tr>
<td>:vsplit [file]</td>
<td>打开新窗口显示file（垂直排列）</td>
</tr>
<tr>
<td>[Ctrl]wh 或 [Ctrl]w←</td>
<td>移动至左一个窗口</td>
</tr>
<tr>
<td>[Ctrl]wj 或 [Ctrl]w↓</td>
<td>移动至下一个窗口</td>
</tr>
<tr>
<td>[Ctrl]wk 或 [Ctrl]w↑</td>
<td>移动至上一个窗口</td>
</tr>
<tr>
<td>[Ctrl]wl 或 [Ctrl]w→</td>
<td>移动至右一个窗口</td>
</tr>
</tbody>
</table>
<h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><p>使用 <code>:set</code> 来进行个性化的设置，通常是对两种类型的变量进行设置：取值型和布尔型。</p>
<ul>
<li>取值型 —— :set var=num</li>
<li>布尔型 —— :set (no)var</li>
</ul>
<p>另外，还有一些设置或是查看信息的命令，它们可能不使用 <code>:set</code> 作为开头。</p>
<h3 id="布尔型变量"><a href="#布尔型变量" class="headerlink" title="布尔型变量"></a>布尔型变量</h3><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:set number</td>
<td>显示行号，number可缩写为nu</td>
</tr>
<tr>
<td>:set hlsearch</td>
<td>设置搜索高亮</td>
</tr>
<tr>
<td>:set autoindent</td>
<td>设置自动缩进，autoindent可缩写为ai</td>
</tr>
<tr>
<td>:set autowrite</td>
<td></td>
</tr>
<tr>
<td>:set cindent</td>
<td>设置C语言的自动缩进，缩进量由shiftwidth控制</td>
</tr>
<tr>
<td>:set ignorecase</td>
<td>不区分大小写，ignorecase可缩写为ic</td>
</tr>
<tr>
<td>:set backup</td>
<td>设置自动备份，backup可缩写为bk</td>
</tr>
<tr>
<td>:set mesg</td>
<td></td>
</tr>
<tr>
<td>:set warn</td>
<td></td>
</tr>
<tr>
<td>:set ruler</td>
<td>显示右下状态栏，ruler可缩写为ru</td>
</tr>
<tr>
<td>:set showmode</td>
<td>显示左下模式信息，showmode可缩写为smd</td>
</tr>
<tr>
<td>:set wrapscan</td>
<td>设置搜索达顶部或底部时能回到底部或顶部，wrapscan可缩写为ws</td>
</tr>
</tbody>
</table>
<h3 id="取值型变量"><a href="#取值型变量" class="headerlink" title="取值型变量"></a>取值型变量</h3><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:set shiftwidth=n</td>
<td>设置偏移量为n个空格，shiftwidth可缩写为sw</td>
</tr>
<tr>
<td>:set window=n</td>
<td>，window可缩写为wi</td>
</tr>
<tr>
<td>:set wrapmargin=n</td>
<td>，wrapmargin可缩写为wm</td>
</tr>
<tr>
<td>:set tabstop=n</td>
<td>设置一个[tab]为n个空格，tabstop可缩写为ts</td>
</tr>
<tr>
<td>:set backspace=[012]</td>
<td>设置backspace是[2]否[01]能够删除任意字符</td>
</tr>
<tr>
<td>:set background=dark</td>
<td>设置颜色色调为深色，background可缩写为bg</td>
</tr>
<tr>
<td>:set background=light</td>
<td>设置颜色色调为浅色，background可缩写为bg</td>
</tr>
<tr>
<td>:set filetype=[filetype]</td>
<td>设置文件类型，如[filetype]取fortran</td>
</tr>
</tbody>
</table>
<h2 id="其他设置及查看信息"><a href="#其他设置及查看信息" class="headerlink" title="其他设置及查看信息"></a>其他设置及查看信息</h2><table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:set</td>
<td>显示与系统默认值不同的设置参数</td>
</tr>
<tr>
<td>:set all</td>
<td>显示当前所有的环境参数设置值</td>
</tr>
<tr>
<td>:syntax on 或 :syntax enable</td>
<td>开启语法高亮</td>
</tr>
<tr>
<td>:syntax off 或 :syntax clear</td>
<td>取消语法高亮</td>
</tr>
<tr>
<td>:nohlsearch</td>
<td>单次取消高亮</td>
</tr>
<tr>
<td>:colorscheme [type]</td>
<td></td>
</tr>
<tr>
<td>:hide edit [file]</td>
<td></td>
</tr>
<tr>
<td>:abbreviate str1 str2</td>
<td>将str1设置为str2的缩写，abbreviate可缩写为ab</td>
</tr>
<tr>
<td>:unabbreviate str</td>
<td>删除已设置的缩写str，unabbreviate可缩写为una</td>
</tr>
<tr>
<td>:abbreviate</td>
<td>查看所有已设置的缩写</td>
</tr>
<tr>
<td>:map key1 key2</td>
<td>将关键字序列key1映射到另一个关键字序列key2</td>
</tr>
<tr>
<td>:unmap key</td>
<td>删除已设置的映射key</td>
</tr>
<tr>
<td>:map</td>
<td></td>
</tr>
<tr>
<td>:registers ([register])</td>
<td>查看所有（[register]）寄存器，registers可缩写为reg</td>
</tr>
<tr>
<td>[Ctrl]g</td>
<td>显示当前文件名和状态</td>
</tr>
<tr>
<td>[Ctrl]l</td>
<td>清除并重画屏幕</td>
</tr>
<tr>
<td>Q</td>
<td>进入Ex模式，之后输visual则返回Normal模式</td>
</tr>
<tr>
<td>:help</td>
<td>打开帮助</td>
</tr>
<tr>
<td>:help [operation]</td>
<td></td>
</tr>
<tr>
<td>:version</td>
<td>查看vi的相关设置信息，可缩写为ve</td>
</tr>
<tr>
<td>[Esc][Esc] 或 [Ctrl][[Ctrl][</td>
<td>命令行模式切换至一般模式</td>
</tr>
<tr>
<td>[Backspace] 或 [Ctrl]h</td>
<td>命令行模式中向左删除一个字符</td>
</tr>
</tbody>
</table>
<h2 id="设置文件"><a href="#设置文件" class="headerlink" title="设置文件"></a>设置文件</h2><p><code>vi</code> 启动时，会自行寻找设置文件来初始化设置。按照以下顺序，<code>vi</code> 将读取找到的第一个文件。</p>
<blockquote>
<p>\$HOME/.vimrc<br>\$HOME/_vimrc<br>\$HOME/.exrc<br>\$HOME/_exrc</p>
</blockquote>
<p>如果使用 <code>vi</code> 的GUI版本，则需要读取 <code>gvimrc</code> 文件。使用 <code>:version</code> 命令可以查看读取了哪些文件。<br>如果想要在打开 <code>vi</code> 后自行读取设置文件，可以使用 <code>:source</code> 命令。<br>如果想要把已修改的设置保存为文件，可以使用 <code>:mkvimrc</code> 和 <code>:mkexrc</code> 命令。<br>如果想在不同的目录读取不同的设置文件，需要在当前目录放置一个 <code>.vimrc</code> 文件，同时在 <code>vi</code> 里设置 <code>:set exrc</code>。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:mkvimrc [file]</td>
<td>将已设置的内容保存成文件[file]，可缩写为mkv</td>
</tr>
<tr>
<td>:version</td>
<td>可查看读取的设置文件，可缩写为ve</td>
</tr>
<tr>
<td>:source [file]</td>
<td>读取包含设置信息的文件，可缩写为so</td>
</tr>
<tr>
<td>:mkexrc [file]</td>
<td>将已设置的内容保存成文件[file]，可缩写为mk</td>
</tr>
<tr>
<td>:scriptnames</td>
<td>查看加载的脚本，可缩写为scr</td>
</tr>
<tr>
<td>:set exrc</td>
<td>设置为读取当前目录的设置文件，exrc可缩写为ex</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown 备忘录]]></title>
      <url>http://nearsc.github.io/2016/06/03/markdown-notes/</url>
      <content type="html"><![CDATA[<p>终于决定要开始整整我的主页了，然后接触到了Markdown，就考虑用它来完成我大部分blog的撰写。虽说使用起来简易方便，没有什么难记的语法，但我感觉自己忘性比较大，还是写个备忘录来记录一下吧。</p>
<a id="more"></a>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>Markdown最为基础的一些语法，不包括那些扩展的功能。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 <code>#</code> 将其设置为标题</p>
<pre><code># 基本语法
## 标题
</code></pre><h2 id="强调字体"><a href="#强调字体" class="headerlink" title="强调字体"></a>强调字体</h2><p>前后使用 <code>**</code> 或 <code>__</code> 使字体变为粗体。<br>前后使用 <code>*</code> 或 <code>_</code> 使字体变为粗体。<br>前后使用 <code>**</code> 或 <code>__</code> 并且前后使用 <code>*</code> 或 <code>_</code> 使字体变为粗斜体。<br>前后使用 <code>~~</code> 使字体被划掉。</p>
<pre><code>**我是粗体**
__我也是粗体__
*我是斜体*
_我也是斜体_
**_我是粗斜体_**
__*我也是粗斜体*__
~~我被划掉了~~
</code></pre><blockquote>
<p><strong>我是粗体</strong><br><strong>我也是粗体</strong><br><em>我是斜体</em><br><em>我也是斜体</em><br><strong><em>我是粗斜体</em></strong><br><strong><em>我也是粗斜体</em></strong><br><del>我被划掉了</del></p>
</blockquote>
<h2 id="引用文字"><a href="#引用文字" class="headerlink" title="引用文字"></a>引用文字</h2><p>使用 <code>&gt;</code> 将其设置为引用。当然，可以不是名人名言。</p>
<pre><code>&gt;Remember the past, know the future.
</code></pre><blockquote>
<blockquote>
<p>Remember the past, know the future.</p>
</blockquote>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>使用4个空格或者1个tab来获得代码块</p>
<pre><code>&lt;Tab&gt;printf(&quot;这是一个代码块&quot;)

printf(&quot;这是一个代码块&quot;)
</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>使用 <code>[]()</code> 来添链加接</p>
<pre><code>详情请访问[Nearsc的主页](http://nearsc.github.io/)
</code></pre><blockquote>
<p>详情请访问<a href="http://nearsc.github.io/">Nearsc的主页</a></p>
</blockquote>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用 <code>![]()</code> 来添加图片</p>
<pre><code>![罗小黑](/images/lxh.gif)
</code></pre><blockquote>
<p><img src="/images/lxh.gif" alt="罗小黑"></p>
</blockquote>
<h2 id="项目清单"><a href="#项目清单" class="headerlink" title="项目清单"></a>项目清单</h2><p>使用数字来添加项目编号<br>使用 <code>-</code> 或 <code>*</code> 或 <code>+</code> 来添加项目符号<br>使用两个空格获得嵌套清单</p>
<pre><code>1. Personal information
  * Nearsc
  * China
2. Hobbies
  1. Music
    - Popular music
    - Classic music
  2. Animation
    + 天空の城ラピュタ
    + 魔女の宅急便
</code></pre><blockquote>
<ol>
<li>Personal information<ul>
<li>Nearsc</li>
<li>China</li>
</ul>
</li>
<li>Hobbies<ol>
<li>Music<ul>
<li>Popular music</li>
<li>Classic music</li>
</ul>
</li>
<li>Animation<ul>
<li>天空の城ラピュタ</li>
<li>魔女の宅急便</li>
</ul>
</li>
</ol>
</li>
</ol>
</blockquote>
<h1 id="GitHub-特殊语法"><a href="#GitHub-特殊语法" class="headerlink" title="GitHub 特殊语法"></a>GitHub 特殊语法</h1><p>包含了部分的 GFM (GitHub Flavored Markdown)</p>
<h2 id="引用代码"><a href="#引用代码" class="headerlink" title="引用代码"></a>引用代码</h2><p>使用 <code>`</code> 来加入一串代码<br><em>嵌入式代码</em> —— 前后各一个<code>`</code></p>
<pre><code>`tar`是Linux下用来打包的命令
</code></pre><blockquote>
<p><code>tar</code>是Linux下用来打包的命令</p>
</blockquote>
<p><em>代码块</em> —— 前后连续三个<code>`</code></p>
<blockquote>
<p>```bash<br>cd ~/Download<br>tar -xvzf netcdf-4.4.0<br>cd netcdf-4.4.0<br>mkdir -p /opt/netcdf/netcdf-4.4.0<br>./configure --prefix=/opt/netcdf/netcdf-4.4.0<br>make all install<br>```</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Download</span><br><span class="line">tar -xvzf netcdf-4.4.0</span><br><span class="line"><span class="built_in">cd</span> netcdf-4.4.0</span><br><span class="line">mkdir -p /opt/netcdf/netcdf-4.4.0</span><br><span class="line">./configure --prefix=/opt/netcdf/netcdf-4.4.0</span><br><span class="line">make all install</span><br></pre></td></tr></table></figure>
<h2 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h2><p>使用 <code>-</code> 和 <code>[ ]</code> 标记为未完成的任务<br>使用 <code>-</code> 和 <code>[x]</code> 标记为已完成的任务</p>
<pre><code>- [x] 给植物浇水
- [ ] 收集雨花石
- [ ] 学画画
</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用 <code>-</code> 和 <code>|</code> 来绘制表格</p>
<pre><code>动画名称|上映年份|代表音乐
-|-|-
風の谷のナウシカ|1984|鸟の人
天空の城ラピュタ|1986|空から降ってきた少女
千と千尋の神隠し|2001|あの夏へ
</code></pre><blockquote>
<table>
<thead>
<tr>
<th>动画名称</th>
<th>上映年份</th>
<th>代表音乐</th>
</tr>
</thead>
<tbody>
<tr>
<td>風の谷のナウシカ</td>
<td>1984</td>
<td>鸟の人</td>
</tr>
<tr>
<td>天空の城ラピュタ</td>
<td>1986</td>
<td>空から降ってきた少女</td>
</tr>
<tr>
<td>千と千尋の神隠し</td>
<td>2001</td>
<td>あの夏へ</td>
</tr>
</tbody>
</table>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
